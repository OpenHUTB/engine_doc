<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">

<!-- Mirrored from docs.unrealengine.com/4.26/zh-CN/ProductionPipelines/DevelopmentSetup/CodingStandard/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 17 Jan 2024 11:10:05 GMT -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="../../../../Include/Javascript/common_zh-CN.js" type="text/javascript"></script>
	<script type="text/javascript">
		var time = new Date(0);
		var preview = false;
		var relativeHTMLPath = "https://docs.unrealengine.com/4.26/";
				var pageid = 0;
				var heroimage = "";
				var lang = "zh-CN";
				var basePath = document.location.pathname.substring(0, document.location.pathname.indexOf('/' + lang + '/') + lang.length + 1);
		document.write('<base href="' +  encodeURI(basePath) + '/ProductionPipelines/DevelopmentSetup/CodingStandard/" />');
				var udnCSS = '../../../../Include/CSS/udn_public.css';
		var udnLangCSS = '';
				udnLangCSS = './../../../../Include/CSS/udn_public_CN.css">';
				var udnOverrideCSS = '../../../../Include/CSS/skin_overrides.css';
		var udnOverrideDarkCSS = '../../../../Include/CSS/skin_overrides_dark.css';
		var fancyboxCSS = '../../../../Include/CSS/jquery.fancybox.css';
		var jqueryuiCSS = '../../../../Include/CSS/jquery-ui.min.css';
		var qtipCSS = '../../../../Include/CSS/jquery.qtip.css';
		var prettifyCSS = '../../../../Include/CSS/prettify.css';
		var navbarCSS = '../../../../Include/CSS/navBar.css';
		var twentytwentyCSS = '../../../../Include/CSS/twentytwenty.css';
		var recommendationsCSS = '../../../../Include/CSS/jquery.recommendations.css';
	</script>
    <title>代码规范 | 虚幻引擎文档</title>
    	    <meta name=viewport content="width=device-width, initial-scale=1" />
	<meta http-equiv="Cache-control" content="no-store">
    <script  src="../../../../Include/Javascript/CustomEvent.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery-3.4.0.min.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/udn.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/udn_extras.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery-ui.min.js" type="text/javascript"></script>
	    <script  src="../../../../Include/Javascript/informational.js" type="text/javascript"></script>
	    <script  src="../../../../Include/Javascript/jquery.fancybox.pack.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.qtip.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/prettify.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.slimscroll.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.event.move.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.twentytwenty.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/lazysizes.min.js" type="text/javascript"></script>
	    <script  src="../../../../Include/Javascript/jquery.recommendations.js" type="text/javascript"></script>
	
    <link async rel="icon" href="../../../../../favicon.png" type="image/x-icon" />
    <link async rel="shortcut icon" href="../../../../../favicon.png" type="image/x-icon" />
    <link async href="../../../../Include/Images/touch_icon.png" rel="apple-touch-icon" />
    <link async href="../../../../Include/Images/touch_icon_114.png" sizes="114x114" rel="apple-touch-icon" />    
		<script  src="../../../../Include/Javascript/CollapsibleLists.js" type="text/javascript"></script>
	<script  src="../../../../Include/Javascript/navigationBarUI.js"></script>
	<script  src="../../../../Include/Javascript/navigationBar.js"></script>
		
	<link rel="alternate" href="https://docs.unrealengine.com/latest/en-US/ProductionPipelines/DevelopmentSetup/CodingStandard/" hreflang="x-default" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/zh-CN/ProductionPipelines/DevelopmentSetup/CodingStandard/" hreflang="zh-CN" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/ja/ProductionPipelines/DevelopmentSetup/CodingStandard/" hreflang="ja" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/ko/ProductionPipelines/DevelopmentSetup/CodingStandard/" hreflang="ko" />

	<meta name="redirect" content="Programming/Development/CodingStandard" />
<meta name="intsourcechangelist" content="16862770" />
<meta name="availability" content="Public" />
<meta name="title" content="代码规范" />
<meta name="description" content="介绍Epic Games在虚幻4代码库中实践的标准和规范。" />
<meta name="version" content="4.21" />
<meta name="type" content="reference" />
<meta name="keywords" content="coding standard" />
<meta name="parent" content="ProductionPipelines/DevelopmentSetup" />
<meta name="order" content="2" />
<meta name="crumbs" content="%ROOT%,ProductionPipelines,ProductionPipelines/DevelopmentSetup" />

	<meta name="twitter:card" content="summary_large_image" />
	<meta property="og:title" content="代码规范" />
	<meta property="og:description" content="介绍Epic Games在虚幻4代码库中实践的标准和规范。" />
		<meta property="og:image" content="" />
	</head>
<body id="webbgThree" style="visibility: hidden;" onload="document.body.style.visibility='visible';">
			<script>window.__tracking_base = 'https://tracking.unrealengine.com/';</script>
	<script src="../../../../../../tracking.unrealengine.com/tracking.js" async></script>    <div id="webThree">
				<div id="page_head">
			<edc-navigation blackListLangCodes='["de-de","es-es","es-mx","fr-fr","it-it","pt-br","ru-ru","pl-pl","tr-tr"]' locale="zh-CN" ></edc-navigation>
						<div id="pagenav">
				<div class="crumbs" id="crumbs">

	<span class="separator">></span> <a id="parent_link" href="../../index.html">建立你的开发流程</a>

	<span class="separator">></span> <a id="parent_link" href="../index.html">开发的相关设置</a>

<span class="separator">></span> <span id="page">代码规范</span>
</div>				<div id="pageNavRight">
								<!-- Start of Search -->
												<div id="search_container">
					<form name="bodySearch" method="get" action="https://www.unrealengine.com/zh-CN/bing-search" onsubmit="return validateSearch()">
						<input type="image" src="../../../../Include/Images/search_box_icon.png" class="searchbutton"/>
						<input type="hidden" name="filter" value="文档" />
						<input type="text" name="keyword" placeholder="搜索文档……" class="searchbox" autocomplete="off"/>
					</form>
				</div>
								<!-- End of Search -->
				<div id="skinContainer">
	<div id="skinSelect" class="btn btn-skin" onclick="ToggleMenu($('#skinMenu'), $(this));"></div>
	<div id="skinMenu">
		<div id="light" class="btn btn-select" onclick="createCookie('skin', 'light', 365);location.reload();">Light Theme</div>
		<div id="dark" class="btn btn-select" onclick="createCookie('skin', 'dark', 365);location.reload();">Dark Theme</div>
	</div>
</div>				</div>
			</div>
		</div>						<div id="navWrapper">
			<div id="nav-filter-container">
				<div id="nav-filter-inner">
					<form>
						<input type="text" placeholder="Filter pages..." id="nav-filter" onchange="clearTimeout(filterTimer); filterTimer = setTimeout(updateNavTreeFilter,250, this.value);if(this.value.length == 0){$('#filter-clear').hide();}else{$('#filter-clear').show();}" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();" />
						<button class="close-icon" id="filter-clear" type="reset" onclick="clearTimeout(filterTimer); filterTimer = setTimeout(updateNavTreeFilter,250, '');$(this).hide();"></button>
					</form>
				</div>
			</div>
			<nav id="navPanel">
			</nav>
			<div id="navigation" title="Click to toggle navigation menu"><span>></span></div>
		</div>		
		<div id="splitter">
		</div>
				<div id="contentContainer">
										<div id="pagedefault">
				<div id="product-banner">
	<div id="product-logo"></div>
</div>				<div id="pagecontainer" style="padding-right:0px;">
					<!-- Start of Markdown converted page content -->
																				<div class="hero  ">
						<div class="imgContainer"><img src="#" /></div>						<div class="info">
							<div id="pageTitle">
								<h1 id="H1TitleId">代码规范</h1>
							</div>	
							<h2 >介绍Epic Games在虚幻4代码库中实践的标准和规范。</h2>
							<div id="access">
								<div class="accessContainer">
																																			</div>
							</div>
						</div>
					</div>
																				<div id="maincol">
						<div class="togglesection" id="osContainer">
	<div class="normaltitle">
		<p>Choose your operating system:</p>
	</div><div class="toggleButtons">
		<div class="btn btn-default btn-toggle OS windows" id="windows" onclick="setSelector('OS', 'windows');">
			<p>Windows</p>
		</div>
		<div class="btn btn-default btn-toggle OS mac" id="mac" onclick="setSelector('OS', 'mac');">
			<p>macOS</p>
		</div>
		<div class="btn btn-default btn-toggle OS linux" id="linux" onclick="setSelector('OS', 'linux');">
			<p>Linux</p>
		</div>
	</div>
</div>																																				<div class="toc">
<div style="position:relative;">
    <div class="title">
    本页面的内容
    </div>
<div id="tocScroll">
    <ul>
	    		    			    <li id="">
	<p><a id="toc_link" href="#类组织">类组织</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#版权声明">版权声明</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#命名规范">命名规范</a></p>
			<ul>
							<li id="">
	<p><a id="toc_link" href="#范例">范例</a></p>
	</li>					</ul>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#可移植的c++代码">可移植的C++代码</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#标准库的使用">标准库的使用</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#注释">注释</a></p>
			<ul>
							<li id="">
	<p><a id="toc_link" href="#指南">指南</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#常量正确性">常量正确性</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#范例格式">范例格式</a></p>
	</li>					</ul>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#现代c++语言语法">现代C++语言语法</a></p>
			<ul>
							<li id="">
	<p><a id="toc_link" href="#静态_断言">静态_断言</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#覆盖与完成">覆盖与完成</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#nullptr">nullptr</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#_自动_关键字">"自动"关键字</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#基于范围">基于范围</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#匿名函数">匿名函数</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#强类型化列举">强类型化列举</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#移动语意（movesemantics）">移动语意（Move Semantics）</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#默认成员初始器">默认成员初始器</a></p>
	</li>					</ul>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#第三方代码">第三方代码</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#代码格式">代码格式</a></p>
			<ul>
							<li id="">
	<p><a id="toc_link" href="#大括号">大括号</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#if-else">If - Else</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#制表符和缩进">制表符和缩进</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#切换语句">切换语句</a></p>
	</li>					</ul>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#命名空间">命名空间</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#物理依赖性">物理依赖性</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#封装">封装</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#一般格式问题">一般格式问题</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#api设计指导方针">API设计指导方针</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#平台特定代码">平台特定代码</a></p>
	</li>		    	        </ul>
</div>
</div>
</div>
<p>在Epic内部，我们会遵循一些基本的代码标准和规范。本文并非旨在探讨当前的某项工作，而是介绍Epic目前采用的代码规范。下文阐述了我们会严格遵守的一些代码规范。
</p><p>代码规范对程序员十分重要，原因有几点：
</p><ul ><li class="Default"><p>软件生命周期中80%的时间皆需要维护。
</p></li><li class="Default"><p>原开发者几乎不会对软件进行终身维护。
</p></li><li class="Default"><p>代码规范可提高软件可读性，让工程师更加快速透彻地理解新代码。
</p></li><li class="Default"><p>如决定向模组社区开发者公开源代码，则源代码需要易于理解。
</p></li><li class="Default"><p>交叉编译器兼容性实际上需要此类规则。
</p></li></ul><p>以下的代码标准以C++为中心，但无论使用何种语言，建议均按此标准执行。在适用情况下，相关章节可为指定语言提供同等规则或例外。
</p><h2 id="类组织">类组织</h2>
<p>通常类均是由读取者进行排列，而非写入者。多数读取者会使用类的公共接口，因此首先需要对此进行声明，之后再声明类的私有实现。
</p><h2 id="版权声明">版权声明</h2>
<p>由Epic提供用于分配的源文件（.h、.cpp、.xaml、etc.）必须在文件的首行包含版权声明。版权声明的格式必须严格按照以下形式编写：
</p><pre class="prettyprint"><code>// Copyright Epic Games, Inc. All Rights Reserved.</code></pre>
<p>若此行缺失或格式错误，CIS将生成错误或失败提示。
</p><h2 id="命名规范">命名规范</h2>
<ul ><li class="Default"><p>所有代码和注释都应采用美式标准英语的拼写和语法。
</p></li><li class="Default"><p>命名（如类型或变量）中的每个单词需大写首字母，单词间通常无下划线。例如：<code>Health</code> 和 <code>UPrimitiveComponent</code>，而非 <code>lastMouseCoordinates</code> 或 <code>delta&#95;coordinates</code>。
</p></li><li class="Default"><p>类型名前缀需使用额外的大写字母，用于区分其和变量命名。例如：<code>FSkin</code> 为类型名，而 <code>Skin</code> 则是 <code>FSkin</code> 的实例。
</p><ul ><li class="Default"><p>模板类的前缀为T。
</p></li><li class="Default"><p>继承自 <code>UObject</code> 的类前缀为U。
</p></li><li class="Default"><p>继承自 <code>AActor</code> 的类前缀为A。
</p></li><li class="Default"><p>继承自 <code>SWidget</code> 的类前缀为S。
</p></li><li class="Default"><p>抽象界面类的前缀为I。
</p></li><li class="Default"><p>列举的前缀为E。
</p></li><li class="Default"><p>布尔变量必须以b为前缀（例如 <code>bPendingDestruction</code> 或 <code>bHasFadedIn</code>）。
</p></li><li class="Default"><p>其他多数类均以F为前缀，而部分子系统则以其他字母为前缀。
</p></li><li class="Default"><p>Typedefs应以任何与其类型相符的字母为前缀：若为结构体的Typedefs，则使用F；若为 <code>Uobject</code> 的Typedefs，则使用U，以此类推。
</p><ul ><li class="Default"><p>特别模板实例化的Typedef不再是模板，并应加上相应前缀，例如：
</p><pre class="prettyprint"><code>typedef TArray&lt;FMytype&gt; FArrayOfMyTypes;</code></pre></li></ul></li><li class="Default"><p>C#中省略前缀。
</p></li><li class="Default"><p>多数情况下，UnrealHeaderTool需要正确的前缀，因此添加前缀至关重要。
</p></li></ul></li><li class="Default"><p>类型和变量的命名为名词。
</p></li><li class="Default"><p>方法名是动词，以描述方法的效果或未被方法影响的返回值。
</p></li></ul><p>变量、方法和类的命名应清楚、明了且进行描述。命名的范围越大，一个良好的描述性命名就越重要。避免过度缩写。
</p><p>所有变量应逐个声明，以便对变量的含义提供注释。其同样被JavaDocs格式需要。变量前可使用多行或单行注释，空白行为分组变量可选使用。
</p><p>所有返回布尔的函数应发起true/false的询问，如`IsVisible()<code>或`ShouldClearBuffer()</code>。
</p><p>程序（无返回值的函数）应在Object后使用强变化动词。一个例外是若方法的Object是其所在的Object；此时需以上下文来理解Object。避免以"Handle"和"Process"为开头；此类动词会引起歧义。
</p><p>若函数参数通过引用传递，同时该值会写入函数，建议以"Out"做为函数参数命名的前缀（非必需）。此操作将明确表明传入该参数的值将被函数替换。
</p><p>若In或Out参数同样为布尔，以b作为In/Out的前缀，如 <code>bOutResult</code>。
</p><p>返回值的函数应描述返回的值.命名应说明函数将返回的值。此规则对布尔函数极为重要。请参考以下两个范例方法：
</p><pre class="prettyprint"><code>// True的意义是什么？
bool CheckTea(FTea Tea);

// 命名明确说明茶是新鲜的
bool IsTeaFresh(FTea Tea);</code></pre>
<h3 id="范例">范例</h3>
<pre class="prettyprint"><code>float TeaWeight;
int32 TeaCount;
bool bDoesTeaStink;
FName TeaName;
FString TeaFriendlyName;
UClass&#42; TeaClass;
USoundCue&#42; TeaSound;
UTexture&#42; TeaTexture;</code></pre>
<h2 id="可移植的c++代码">可移植的C++代码</h2>
<ul ><li class="Default"><p><code>bool</code> 代表布尔值（不会假定布尔尺寸）。<code>BOOL</code> 不会进行编译。
</p></li><li class="Default"><p><code>TCHAR</code> 代表字符（不会假定TCHAR尺寸)。
</p></li><li class="Default"><p><code>uint8</code> 代表无符号字节（1字节）。
</p></li><li class="Default"><p><code>int8</code> 代表带符号字节（1字节）。
</p></li><li class="Default"><p><code>uint16</code> 代表无符号"短"字符（2字节）。
</p></li><li class="Default"><p><code>int16</code> 代表带符号"短"字符（2字节）。
</p></li><li class="Default"><p><code>uint32</code> 代表无符号整数（4字节）。
</p></li><li class="Default"><p><code>int32</code> 代表带符号整数（4字节）。
</p></li><li class="Default"><p><code>uint64</code> 代表无符号"四字"（8字节）。
</p></li><li class="Default"><p><code>int64</code> 代表带符号"四字"（8字节）。
</p></li><li class="Default"><p><code>float</code> 代表单精确浮点（4字节）。
</p></li><li class="Default"><p><code>double</code> 代表双精确浮点（8字节）。
</p></li><li class="Default"><p><code>PTRINT</code> 代表可能含有指针的整数（不会假定PTRINT尺寸）。
</p></li></ul><p>在某些情况下，整型长度的影响并不重要，这时你可以使用C++中的 <code>int</code> 类型和无符号 <code>int</code> 类型；这些类型的长度会随平台而变化，但至少能保证32位长度。在涉及序列化或复制类型的格式时，仍然必须使用长度明确的类型。
</p><h2 id="标准库的使用">标准库的使用</h2>
<p>过去，UE避免直接使用C和C++标准库。造成这种情况的原因有很多种，其中包括：用我们自己的实现替代低效缓慢的实现、允许对内存分配进行额外控制、在可用的新功能广泛出现前先自己"丰衣足食"、进行合适但非标准化的行为更改、在代码库中使用一致的语法、避免采用与UE习惯用法不相容的结构。但是，近年来，随着标准库愈发稳定和成熟，它包含了许多我们自己不想用抽象层封装或重新实现的功能。
</p><p>假如希望使用之前从未用过的全新标准库组件，则应将这类情况提交给代码规范小组进行评估。这还有助于我们把组件添加到白名单后，保持白名单为最新状态。
</p><p>当可以在标准库和我们自己的库之间选择时，请选择能提供更优结果的方案，但请记住，一致性也非常重要。如果某个长期使用的UE实现无法再满足需求，我们就可以选择弃用它，并改用标准库。
</p><p>应该避免在同一API中混合使用UE规范和标准库规范。
</p><p><code>&lt;atomic&gt;</code>：应在新代码中使用，在迁移旧代码时也应该使用。原子性（Atomic）将在所有受支持平台上高效推广。我们自己的 <code>TAtomic</code> 仅实现了部分功能，对我们而言，对它继续进行维护和改善已没有太大意义。
</p><p><code>&lt;type&#95;traits&gt;</code>：应在旧版UE特性（trait）和标准特性重叠的地方使用。特性（trait）通常作为编译器内在函数（compiler intrinsic）实现，从而确保正确性，且编译器可以了解标准特性并选择更快的编译路径，而不必将其视为纯C++。值得关注的是，我们的特性通常具有大写的 <code>Value</code> "static"关键字或 <code>Type</code> "typedef"关键字，而标准特性则使用 <code>value</code> 和 <code>type</code>。这是一项重要区别，因为组合特性需要特定语法，如 <code>std::conjunction</code>。我们添加的新特性应使用小写的 <code>value</code> 或 <code>type</code> ，以便支持组合，而现有特性应更新，以便支持任一情况。
</p><p><code>&lt;initializer&#95;list&gt;</code>：必须用于支持初始化器（initializer）语法（用括号括起来）。这种情况下，语言和标准库会产生重叠，如果你想支持这种情况，则没有其他方案。
</p><p><code>&lt;regex&gt;</code>：可以直接使用，但其使用应封装在仅和编辑器有关的代码中。我们没有计划实现自己的正则表达式（regex）解决方案。
</p><p><code>&lt;limits&gt;</code>： <code>std::numeric&#95;limits</code> 可以完整使用。
</p><p><code>&lt;cmath&gt;</code>： 这个头文件中只有浮点比较函数可以使用，具体参见<a id="content_link" href="https://en.cppreference.com/w/cpp/header/cmath#Classification_and_comparison" ><span>此处</span></a>。
</p><p>除了Interop作代码外，应避免使用标准容器和字符串。
</p><h2 id="注释">注释</h2>
<p>注释即沟通，而沟通极为重要。请牢记以下几点有关注释的信息（摘取自Kernighan &amp; Pike的著作 <em>《The Practice of Programming》</em>）：
</p><h3 id="指南">指南</h3>
<ul ><li class="Default"><p>编写含义清晰的代码：
</p><pre class="prettyprint"><code>// 错误示范：
t = s + l - b;

// 正确示范：
TotalLeaves = SmallLeaves + LargeLeaves - SmallAndLargeLeaves;</code></pre></li></ul><ul ><li class="Default"><p>编写有用的注释：
</p><pre class="prettyprint"><code>// 错误示范：
// increment Leaves
++Leaves;

// 正确示范：
// we know there is another tea leaf
++Leaves;</code></pre></li></ul><ul ><li class="Default"><p>不要对低质量代码进行注释——重新编写这些代码：
</p><pre class="prettyprint"><code>// 错误示范：
// total number of leaves is sum of
// small and large leaves less the
// number of leaves that are both
t = s + l - b;

// 正确示范：
TotalLeaves = SmallLeaves + LargeLeaves - SmallAndLargeLeaves;</code></pre></li></ul><ul ><li class="Default"><p>不要让代码与注释自相矛盾：
</p><pre class="prettyprint"><code>// 错误示范：
// never increment Leaves!
++Leaves;

// 正确示范：
// we know there is another tea leaf
++Leaves;</code></pre></li></ul><h3 id="常量正确性">常量正确性</h3>
<p>常量即是文档也是编译器指令，因此应保证所有代码的常量正确。
</p><p>其中包括：
</p><ul ><li class="Default"><p>若函数不修改参数，常量指针或引用将传递函数参数，
</p></li><li class="Default"><p>若方法不修改对象，将方法标记为常量，。
</p></li><li class="Default"><p>若循环不修改容器，则在容器上使用常量迭代。
</p></li></ul><p>范例：
</p><pre class="prettyprint"><code>void SomeMutatingOperation(FThing&amp; OutResult, const TArray&lt;Int32&gt;&amp; InArray)
{
    // 此处不会修改InArray，但可能会修改OutResult
}

void FThing::SomeNonMutatingOperation() const
{
    // 若此代码在FThing上被调用，其不会修改FThing
}

TArray&lt;FString&gt; StringArray;
for (const FString&amp; :StringArray)
{
    // 此循环的主体不会修改StringArray
}</code></pre>
<p>基于值的函数参数和本地值通用倾向常量。读取者可了解函数主体不会修改变量，使之更为易懂。操作影响JavaDoc进程，因此进行此操作时须确保声明与定义相匹配：
</p><p>范例：
</p><pre class="prettyprint"><code>void AddSomeThings(const int32 Count);

void AddSomeThings(const int32 Count)
{
    const int32 CountPlusOne = Count + 1;
    // 函数主体不会改变Count或CountPlusOne
}</code></pre>
<p>一个例外是按值传递参数，这种参数最终会被移动到容器中（见"移动语义"），不过这种参数应该很少见。
</p><p>范例：
</p><pre class="prettyprint"><code>void FBlah::SetMemberArray(TArray&lt;FString&gt; InNewArray)
{
    MemberArray = MoveTemp(InNewArray);
}</code></pre>
<p>创建指针的常量时，将常量关键字放在末尾（而非指针所指之处）。无法"重新指定"引用，因此无法以相同方式创建常量：
</p><p>范例：
</p><pre class="prettyprint"><code>// 非常量对象的常量指针——无法重新指定指针，但仍可修改T
T&#42; const Ptr = ...;

// 非法
T&amp; const Ref = ...;</code></pre>
<p>绝不要在返回类型上使用常量，此操作将会禁止复杂类型的移动语意，并会对内置类型发出编译警告。此规则仅适用于返回类型自身，而非指针目标类型或返回的引用。
</p><p>范例：
</p><pre class="prettyprint"><code>// 差 - 返回常量数组
const TArray&lt;FString&gt; GetSomeArray();

// 优 - 返回常量数组的引用
const TArray&lt;FString&gt;&amp; GetSomeArray();

// 优 - 返回指向常量数组的指针
const TArray&lt;FString&gt;&#42; GetSomeArray();

// 差 - 返回指向常量数组的常量指针
const TArray&lt;FString&gt;&#42; const GetSomeArray();</code></pre>
<h3 id="范例格式">范例格式</h3>
<p>通常适用基于JavaDoc的系统从代码和版本文档中自动提取注释，因此需要遵守几项特别的注释格式规则。
</p><p>以下例子展示的是类、状态、方法和变量注释的格式。记住：注释应扩大代码。代码说明实现，而注释说明意图。代码记载实现，而注释记载目的。修改代码的部分目的后应及时更新注释。
</p><p>注意：支持两种不同的参数注释格式，具体为 <code>Steep</code> 和 <code>Sweeten</code> 方法。<code>Steep</code> 使用的是传统 <code>@param</code> 多行格式，如Sweeten范例所示，对简单函数而言Steep方式可更加清晰地将参数和值文档整合到函数的描述性注释中。如 <code>@see</code> 或 <code>@return</code> 等特殊注释标签仅用于在主要注释后另起新行。
</p><p>方法注释仅能在其公开声明的地方使用一次。方法注释仅包含与方法调用者有关的信息，包括任何可能与调用者有关的方法覆盖信息。与调用者无关的方法实现和覆盖的相关细节应在方法实现中进行注释。
</p><pre class="prettyprint"><code>/&#42;&#42; 可饮用物的接口。&#42;/
class IDrinkable
{
public:
    /&#42;&#42;
     &#42; 玩家喝下此物时调用。
     &#42; @param OutFocusMultiplier - 返回时将包含应用至喝下者聚焦的乘数。
     &#42; @param OutThirstQuenchingFraction - 返回时将包含喝下者渴度的冷却小数（0-1）。
     &#42; @warning 仅在饮料准备好后调用此。     
     &#42;/
    virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) = 0;
};

/&#42;&#42; 单杯茶。&#42;/
class FTea : public IDrinkable
{
public:
    /&#42;&#42;
     &#42; 根据茶叶浸泡时的水的体积和温度，计算出茶叶的差量食味值。
     &#42; @param VolumeOfWater - 用于冲泡的水量（以毫升计）
     &#42; @parama TemperatureOfWater - 水温（以开氏度计）
     &#42; @param OutNewPotency - 开始浸泡后茶的效力（0.97到1.04）
     &#42; @return 茶每分钟的强度变化（以茶食味值TTU计）
     &#42;/
    float Steep(
        const float VolumeOfWater,
        const float TemperatureOfWater,
        float&amp; OutNewPotency
    );

    /&#42;&#42; 向茶添加甜料，以产生相同甜度的蔗糖克数计量。&#42;/
    void Sweeten(const float EquivalentGramsOfSucrose);

    /&#42;&#42; 日本销售的茶量（以日元计）。&#42;/
    float GetPrice() const
    {
        return Price;
    }

    virtual void Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction) override;

private:
    /&#42;&#42; 价格（日元） &#42;/
    float Price;

    /&#42;&#42; 当前甜度，以同等蔗糖克数计量 &#42;/
    float Sweetness;
};

float FTea::Steep(const float VolumeOfWater, const float TemperatureOfWater, float&amp; OutNewPotency)
{
    ...
}

void FTea::Sweeten(const float EquivalentGramsOfSucrose)
{
    ...
}

void FTea::Drink(float&amp; OutFocusMultiplier, float&amp; OutThirstQuenchingFraction)
{
    ...
}</code></pre>
<p>类注释包括什么？
</p><ul ><li class="Default"><p>此类解决的问题的描述。
</p></li><li class="Default"><p>创建此类的原因。
</p></li></ul><p>多行法注释的所有部分的意义为何？
</p><ol ><li class="Default"><p><strong>函数目的</strong>：记载 <code>该函数解决的问题</code>。如上所述，注释记载 <code>目的</code> 而代码记载 <code>实现</code>。
</p></li><li class="Default"><p><strong>参数注释</strong>：所有参数注释应包括：
</p><ul ><li class="Default"><p>计量单位，
</p></li><li class="Default"><p>预期值范围，
</p></li><li class="Default"><p>"无可能"值
</p></li><li class="Default"><p>以及状态/错误代码的含义。
</p></li></ul></li><li class="Default"><p><strong>返回注释</strong>：其记载预期返回值的方式与记载输出变量相同。为了避免冗余，如函数的唯一目的返回此值，且已函数目的中进行记载，则不应使用显式@return注释。
</p></li><li class="Default"><p><strong>其他信息</strong>：可选择使用 <code>@warning</code>、<code>@note</code>、<code>@see</code> 和 <code>@deprecated</code> 记载额外相关信息。此类注释应在其他注释后单列一行声明。
</p></li></ol><h2 id="现代c++语言语法">现代C++语言语法</h2>
<p>虚幻引擎的设计使起可带规模移植到众多C++编译器中，因此需谨慎使用与可能支持的编译器兼容的功能。有些功能十分有用，因此大家习惯将其包裹在宏中进行大范围使用。但建议在可能支持的编译器更新至最新标准前不要进行类似操作。
</p><p>目前所使用的C++14部分语言功能在现代编译器上普遍有着很好的支持，例如基于范围、移动语意和捕捉初始器的匿名函数。某些情况下，可将此类功能包裹到预处理条件语句中进行使用（例如容器中的右值引用）。但某些语言功能会导致新平台无法消化语法，因此需要避免使用此类功能。
</p><p>除非在以下指定为可支持的现代C++编译器功能，否则在指定编译器的语言功能被包裹到预处理宏或条件语句并节制使用前，不应使用指定编译器的语言功能。
</p><h3 id="静态_断言">静态_断言</h3>
<p>需要编译时断言时，此关键字有效。
</p><h3 id="覆盖与完成">覆盖与完成</h3>
<p>推荐使用此类关键字。文中可能遗漏了此内容，但在之后会进行补充。
</p><h3 id="nullptr">nullptr</h3>
<p>所用情况下均使用 <code>nullptr</code>，而非C-style <code>NULL</code> 宏。
</p><p>此情况有一例外：C++/CX版本（如Xbox One）中的 <code>nullptr</code> 实际上为已管理的空引用类型。其主要与原声C++中的 <code>nullptr</code> 兼容（与其类型相同的和部分模板实例化情景除外），因此应使用 <code>TYPE&#95;OF&#95;NULLPTR</code> 宏进行兼容，而非更为常用的 <code>decltype（nullptr）</code>。
</p><h3 id="_自动_关键字">"自动"关键字</h3>
<p>不应在C++代码中使用 <code>自动</code> 模式，但以下范例除外。必须时刻清楚正在初始化的类型。其意味着读取者必须明确可见此类型。此规则同样适用于C#中 <code>var</code> 关键字的使用。
</p><p>什么时候可以使用 <code>自动</code> 模式？
</p><ul ><li class="Default"><p>需要将匿名函数与变量绑定时。因为代码中无法表达匿名函数类型。
</p></li><li class="Default"><p>仅迭代器类型冗长且会损坏可读性时，适用于迭代函数。
</p></li><li class="Default"><p>无法清楚识别表达式的模板代码中适用。此为高阶情况。
</p></li></ul><p>类型应对读取代码者清晰可见，这一点至关重要。部分IDE能够推断类型，但此操作需要代码处于编译状态。其同样不会协助用户进行合并/对比，或在隔离中查看GitHub等单个源文件时的用户
</p><p>若正以合适方式使用 <code>自动</code> 模式，请牢记使用正确常量，以及与类型命名相同的&amp;或*。在 `自动` 模式的协助下，此操作将使推断类型强制为所需的任何事物。
</p><h3 id="基于范围">基于范围</h3>
<p>利用此可更易理解代码，也更易进行维护。。使用老旧 <code>TMap</code> 迭代器迁移代码时，请注意老旧的 <code>Key()</code> 和 <code>Value()</code> 函数之前是迭代器类型的方法，而现在只是下方键值 <code>TPair</code> 的 <code>键</code> 和 <code>值</code> 域：
</p><p>范例：
</p><pre class="prettyprint"><code>TMap&lt;FString, int32&gt; MyMap;

// 旧样式
for (auto It = MyMap.CreateIterator(); It; ++It)
{
    UE&#95;LOG(LogCategory, Log, TEXT("Key:%s, Value:%d"), It.Key(), &#42;It.Value());
}

// 新样式
for (TPair&lt;FString, int32&gt;&amp; Kvp :MyMap)
{
    UE&#95;LOG(LogCategory, Log, TEXT("Key:%s, Value:%d"), &#42;Kvp.Key, Kvp.Value);
}</code></pre>
<p>部分独立迭代器类型拥有替代范围。
</p><p>范例：
</p><pre class="prettyprint"><code>// 旧样式
for (TFieldIterator&lt;UProperty&gt; PropertyIt(InStruct, EFieldIteratorFlags::IncludeSuper); PropertyIt; ++PropertyIt)
{
    UProperty&#42; Property = &#42;PropertyIt;
    UE&#95;LOG(LogCategory, Log, TEXT("Property name:%s"), &#42;Property-&gt;GetName());
}

// 新样式
for (UProperty&#42; Property :TFieldRange&lt;UProperty&gt;(InStruct, EFieldIteratorFlags::IncludeSuper))
{
    UE&#95;LOG(LogCategory, Log, TEXT("Property name:%s"), &#42;Property-&gt;GetName());
}</code></pre>
<h3 id="匿名函数">匿名函数</h3>
<p>可以自由使用匿名函数。最佳的匿名函数长度不应超过两条语句，作为较大表达式或语句的一部分时尤为如此。例如作为泛型算法中的谓词时：
</p><p>范例：
</p><pre class="prettyprint"><code>// 查找名字含有"Hello"一次的事物
Thing&#42; HelloThing = ArrayOfThings.FindByPredicate(&#91;&#93;(const Thing&amp; Th){ return Th.GetName().Contains(TEXT("Hello")); });

// 以命名倒序排列阵列
Algo::Sort(ArrayOfThings, &#91;&#93;(const Thing&amp; Lhs, const Thing&amp; Rhs){ return Lhs.GetName() &gt; Rhs.GetName(); });</code></pre>
<p>注意：常用的状态性匿名函数无法指定至函数指针。
</p><p>非浅显匿名函数应使用正则函数相同的方式进行记载。建议将其分为数行，以便添加注释。
</p><p>应使用显式捕捉，而非自动捕捉（<code>&#91;&amp;&#93;</code> 和 <code>&#91;=&#93;</code>）。对于可读性、可维护性和性能而言，特别是使用大量匿名函数和延迟执行时，此操作非常重要。其可声明作者的目的，以便在检查代码时找出错误。错误的捕捉会造成负面结果，这种情况在随时间维护代码时更易发生。
</p><ul ><li class="Default"><p>若匿名函数的执行被延迟，指针（包括 <code>此</code> 指针）的通过引用捕捉和通过值捕捉会意外造成悬空引用
</p></li><li class="Default"><p>若创建非延迟匿名函数非必需副本，通过值捕捉将影响性能。
</p></li><li class="Default"><p>意外捕捉的UObject指针对垃圾回收器是不可见的。如引用成员变量，即使 <code>&#91;=&#93;</code> 可使匿名函数产生包含自身信息副本的错觉，自动捕捉也将隐式捕捉 <code>此</code>。
</p></li></ul><p>大型匿名函数或返回另一函数调用的结果时，倾向使用显式返回类型。此类操作与 <code>自动</code> 关键字相同：
</p><pre class="prettyprint"><code>// 此处无返回类型，返回类型不清楚
auto Lambda = &#91;&#93;() -&gt; FMyType
{
    return SomeFunc();
}</code></pre>
<p>浅显非延迟匿名函数接受自动捕捉和隐式返回类型。例如，排序调用中的语意明显且为显式，将使其过度冗长。
</p><p>可使用C++14中的捕捉初始器功能：
</p><pre class="prettyprint"><code>TUniquePtr&lt;FThing&gt; ThingPtr = MakeUnique&lt;FThing&gt;();
AsyncTask(&#91;UniquePtr = MoveTemp(UniquePtr)&#93;()
{
    // 此处使用UniquePtr
});</code></pre>
<h3 id="强类型化列举">强类型化列举</h3>
<p>对于普通列举和 <code>UENUM</code>，列举类应固定作为旧格式命名空间列举的替换使用。例如：
</p><pre class="prettyprint"><code>// 旧列举
UENUM()
namespace EThing
{
    enum Type
    {
        Thing1,
        Thing2
    };
}

// 新列举
UENUM()
enum class EThing : uint8
{
    Thing1,
    Thing2
}</code></pre>
<p>此操作同时支持 <code>UPROPERTY</code>，作为替换旧的 <code>TEnumAsByte&lt;&gt;</code> 解决方案：列举属性可为任何大小，而非仅为字节大小：
</p><pre class="prettyprint"><code>// 旧属性
UPROPERTY()
TEnumAsByte&lt;EThing::Type&gt; MyProperty;

// 新属性
UPROPERTY()
EThing MyProperty;</code></pre>
<p>但公开到蓝图的列举依旧须基于 <code>uint8</code>。
</p><p>用作标志的列举类可以利用 <code>ENUM&#95;CLASS&#95;FLAGS(EnumType)</code> 宏自动定义所有按位运算符：
</p><pre class="prettyprint"><code>enum class EFlags
{
    None = 0x00,
    Flag1 = 0x01,
    Flag2 = 0x02,
    Flag3 = 0x04
};

ENUM&#95;CLASS&#95;FLAGS(EFlags)</code></pre>
<p>有一例外：<em>真实</em> 情景中标签的使用——此为语言的局限。相反，所有标签列举应含有名为 <code>空</code> 的列举器，并将其设为0以进行对比：
</p><pre class="prettyprint"><code>// 旧
if (Flags &amp; EFlags::Flag1)

// 新
if ((Flags &amp; EFlags::Flag1) != EFlags::None)</code></pre>
<h3 id="移动语意（movesemantics）">移动语意（Move Semantics）</h3>
<p><code>TArray</code>、<code>TMap</code>、<code>TSet</code>、<code>FString</code> 等所有主要容器类型含有移动构造函数与移动赋值运算符。通过值传递/返回这些类型时，通常自动使用这些容器，但使用 <code>MoveTemp`可对其进行显式调用，其等同于UE4的 </code>std::move`。
</p><p>通过值返回容器或字符串适用于表达式，而无需临时副本的通常开销。通过值传递和<code> MoveTemp</code> 的使用之规则仍在制定，但已可在基础代码的部分已优化区域中被找到。
</p><h3 id="默认成员初始器">默认成员初始器</h3>
<p>默认成员初始器可用于定义类自身中默认类：
</p><pre class="prettyprint"><code>UCLASS()
class UTeaOptions : public UObject
{
    GENERATED&#95;BODY()

public:
    UPROPERTY()
    int32 MaximumNumberOfCupsPerDay = 10;

    UPROPERTY()
    float CupWidth = 11.5f;

    UPROPERTY()
    FString TeaType = TEXT("Earl Grey");

    UPROPERTY()
    EDrinkingStyle DrinkingStyle = EDrinkingStyle::PinkyExtended;
};</code></pre>
<p>按此编写的代码有以下优势：
</p><ul ><li class="Default"><p>无需跨多个构造函数重复初始器。
</p></li><li class="Default"><p>不会打乱初始化顺序和声明顺序。
</p></li><li class="Default"><p>成员类型、属性标志和默认值均在一处，便于阅读及维护。
</p></li></ul><p>其也存在以下几类劣势：
</p><ul ><li class="Default"><p>需重新编译依赖文件才能修改默认设置。
</p></li><li class="Default"><p>引擎的补丁中无法修改头文件，此格式将限制修复的类型。
</p></li><li class="Default"><p>部分对象无法以此方式格式化，例如基类、<code>UObject</code> 子对象、前置声明类型的指针、构造函数参数的推断值、多步骤初始化成员等。
</p></li><li class="Default"><p>如将部分初始器放入头文件，而其余在.cpp文件的构造函数中，可能会影响可读性和可维护性。
</p></li></ul><p>请谨慎考虑是否使用。根据经验而言，默认成员初始器更适用于游戏代码而非引擎代码。同样也可考虑使用默认值的配置文件。
</p><h2 id="第三方代码">第三方代码</h2>
<p>修改引擎中使用的库的代码时，请务必以//@UE4注释标记变更，以及修改理由。此操作能够将变更以更简便的方式合并到库中，使注册者可轻松查找到做出的变更。
</p><p>引擎中的第三方代码需标有注释，该注释应可被轻易查找。例如：
</p><pre class="prettyprint"><code>// @third party code - BEGIN PhysX
#include &lt;physx.h&gt;
// @third party code - END PhysX
// @third party code - BEGIN MSDN SetThreadName
// &#91;http://msdn.microsoft.com/en-us/library/xcb2z8hs.aspx&#93;
// 用于在调试器中设置线程命名
...
//@third party code - END MSDN SetThreadName</code></pre>
<h2 id="代码格式">代码格式</h2>
<h3 id="大括号">大括号</h3>
<p>大括号格式必须一致。在Epic的传统做法中，大括号固定被放在新行。请遵循此格式。
</p><p>固定在单语句块中使用大括号。例如：
</p><pre class="prettyprint"><code>if (bThing)
{
    return;
}</code></pre>
<h3 id="if-else">If - Else</h3>
<p>if-else语句中的所有执行块都应该使用大括号。此举是为防止编辑时出错——未使用大括号时，可能会意外地将另一行加入if块中。多余行不受if表达式控制，会成为较差代码。条件编译的项目导致if/else语句中断时，也会造成不良结果。因此务必使用大括号。
</p><pre class="prettyprint"><code>if (bHaveUnrealLicense)
{
    InsertYourGameHere();
}
else
{
    CallMarkRein();
}</code></pre>
<p>若多向if语句的缩进量与首条if语句的缩进量相同，则应互相缩进。此操作可提高结构体的可读性：
</p><pre class="prettyprint"><code>if (TannicAcid &lt; 10)
{
    UE&#95;LOG(LogCategory, Log, TEXT("Low Acid"));
}
else if (TannicAcid &lt; 100)
{
    UE&#95;LOG(LogCategory, Log, TEXT("Medium Acid"));
}
else
{
    UE&#95;LOG(LogCategory, Log, TEXT("High Acid"));
}</code></pre>
<h3 id="制表符和缩进">制表符和缩进</h3>
<p>以下为代码缩进的标准。
</p><ul ><li class="Default"><p>通过执行块缩进代码。
</p></li><li class="Default"><p>在行的起始使用制表符，而非空格将制表符设为4字符。有时则需要使用空格，以便忽略制表符的空格数保持代码对齐。例如：以无制表符字符对齐代码。
</p></li><li class="Default"><p>若在C#中编写代码，请同样使用制表符，而非空格。因为程序员时常在C#和C++间切换，且更倾向使用制表符的统一设置。Visual Studio默认在C#文件中使用空格，因此在编写虚幻引擎代码时请变更此设置。
</p></li></ul><h3 id="切换语句">切换语句</h3>
<p>除空白条件外（拥有相同代码的多个选择），切换条件语句应显式标注条件将会落入另一条件。各条件应包含中断或落入注释。其他代码控制传输命令（返回、继续等）同样适用。
</p><p>固定设有默认条件，其中包含有中断，以防在默认后添加新的条件。
</p><pre class="prettyprint"><code>switch (condition)
{
    case 1:
        ...
        // 落入

    case 2:
        ...
        break;

    case 3:
        ...
        return;

    case 4:
    case 5:
        ...
        break;

    default:
        break;
}</code></pre>
<h2 id="命名空间">命名空间</h2>
<p>可在合适之处使用命名空间组织类、函数和变量，使用时需要遵循以下规则。
</p><ul ><li class="Default"><p>大多数UE代码目前尚未包裹在整体命名空间中。。在整体作用域中避免碰撞，特别是在使用或包括第三方代码时。
</p></li><li class="Default"><p>UnrealHeaderTool不支持命名空间，所以命名空间不应在定义 <code>UCLASSes</code>、`USTRUCTs`等时使用。
</p></li><li class="Default"><p>假如新的API不属于 <code>UCLASSes</code>、<code>USTRUCTs</code> 等，则至少应该位于 <code>UE::</code> 命名空间中，并且最好位于嵌套的命名空间中，例如 <code>UE::Audio::</code>。假如某个命名空间保管着实现细节，并且该实现细节不属于面向公众的API，则应位于 <code>Private</code> 命名空间中，例如 <code>UE::Audio::Private::</code>。
</p></li><li class="Default"><p><code>使用</code> 声明：
</p><ul ><li class="Default"><p>请勿将 <code>使用</code> 声明加入整体作用域中，也不能放入.cpp文件中（其会导致"统一"构建系统出错。）
</p></li><li class="Default"><p>可将 <code>使用</code> 放入其他命名空间或函数中体中。
</p></li><li class="Default"><p>若将 <code>使用</code> 声明放入命名空间，其会带入同一翻译单元中的其他命名空间。只需保持一致即可。
</p></li><li class="Default"><p>只有遵守以上规则，才能在头文件中使用 <code>using</code> 声明。
</p></li></ul></li><li class="Default"><p>注意：前置声明需要在各自命名空间中进行声明。否则将造成链接错误。
</p></li><li class="Default"><p>若在命名空间中声明过多类/类型，将导致在其他整体作用域中使用这些类型时出现困难。（例如出现在类声明时，函数签名需要使用显式命名空间。）。
</p></li><li class="Default"><p>可使用 <code>使用</code> 仅为命名空间中的变量在作用域中命名别称（例如（使用 <code>Foo::FBar</code>）。但在虚幻代码中并不常用。
</p></li><li class="Default"><p>宏无法存在于命名空间中，但应使用 <code>UE&#95;</code> 作为前缀，例如 <code>UE&#95;LOG</code>。
</p></li></ul><h2 id="物理依赖性">物理依赖性</h2>
<ul ><li class="Default"><p>文件名应尽量不添加前缀。例如使用 <code>Scene.cpp</code>，而非 <code>UnScene.cpp</code>。此操作可通过减少用于标识文件的字母数，实现在解决方案中使用工作区Whiz或Visual Assist的打开文件等工具。
</p></li><li class="Default"><p>设置指令后所有头文件应防止使用含有 <code>#pragma once`等多种格式。注意：需要使用的编译器现在均支持使用 </code>#pragma once。
</p><pre class="prettyprint"><code>#pragma once
//&lt;file contents&gt;</code></pre></li></ul><ul ><li class="Default"><p>通常需要最小化物理耦合。特别是，避免包含来自其他头文件的标准库头文件。
</p></li><li class="Default"><p>若可使用前置声明，而非头文件，请使用前置声明。
</p></li><li class="Default"><p>包含时尽量细粒化。例如，勿包含Core.h，而在核心中包含需要定义的特定头文件。
</p></li><li class="Default"><p>直接包含全部所需头文件，以便进行细粒化包含。
</p></li><li class="Default"><p>请勿依赖被包含的其他头文件间接包含的头文件。
</p></li><li class="Default"><p>请勿依赖利用其他头文件进行包含。应包含所需的全部对象。
</p></li><li class="Default"><p>模块含有私有和公开源目录。其他模块所需定义必须在公开目录的头文件中。剩余的定义需在私有目录中。注意：在较老的虚幻模块中，此类目录可能被称为"Src"和"Inc"，但此类目录用于区分私有和公开代码的方式则相同，同时不会将头文件文件和源文件进行区分。
</p></li><li class="Default"><p>不必再为了预编译头文件生成（precompiled header generation）相关的头文件设置而担心。使用UnrealBuildTool的效率更高。
</p></li><li class="Default"><p>将大型函数拆分为逻辑子函数。编译器优化一方面是消除常用的子表达式。而函数越大，编译器进行辨识的工作量就越大。从而导致编译时间大大增长。
</p></li><li class="Default"><p>，内联函数会强制在不使用其的文件中强行编译，因此勿使用过多内联函数。内联函数仅可在浅显访问器中和分析显示有益时使用。
</p></li><li class="Default"><p>使用 <code>FORCEINLINE</code> 时需更加谨慎。所有代码和本地变量将扩展至调用函数中，将导致与大型函数相同的编译时间问题。
</p></li></ul><h2 id="封装">封装</h2>
<p>使用保护关键字强制进行封装。除非其是类的公开/保护接口的一部分，否则应固定讲类成员声明为私有。请谨慎使用，但缺少存取器时，在不破坏插件和现有项目的情况下，重构插件将非常困难。
</p><p>若特定域仅能通过派生类使用，将其设置为私有并提供受保护的存取器。
</p><p>若类并非用于派生，则使用完成。
</p><h2 id="一般格式问题">一般格式问题</h2>
<ul ><li class="Default"><p>最小化依赖性距离。代码基于有特定值的变量时，在使用该变量时设定其的值。在执行块顶部初始化变量，且不将其用于一百行代码，将可能导致在未意识到依赖性的情况下意外地更改值。将其设在下行中，可明确变量初始化的原因及其工作区域。
</p></li><li class="Default"><p>尽量将方法拆分为子方法。纵观全局，再深入查看感兴趣的细节，而不会以细节入手，最后重构全局。此类操作更加容易。相较于包含子方法全部代码的同等方法，若以此方法，理解调用多个命名优良的子方法序列的简易方法会更为容易。
</p></li><li class="Default"><p>在函数声明或函数调用站中，请勿在函数命名和设参数列表为优先的空括号间添加空格。
</p></li><li class="Default"><p>修复编译器警告。出现编译器警告消息意味着某些项目出错。应修复编译器警告的内容。如无法修复，使用 <code>#pragma</code> 压制警告，此为最后补救办法。
</p></li><li class="Default"><p>在文件末尾留下空白行。所有.cpp和.h文件应包含空白行，以便和gcc兼容。
</p></li><li class="Default"><p>调试代码需为有用并经过优化，或为已迁入。与其他代码相互混杂的调试代码将导致读取其他代码时出现困难。
</p></li><li class="Default"><p>在字符串文字周围固定使用 <code>TEXT()</code> 宏。若未使用，在文字中构建 <code>FStrings</code> 的代码将导致不理想的字符转换过程。
</p></li><li class="Default"><p>避免循环相同的多余运算。将常用子表达式从循环中移出，以避免冗余计算。在某些情况下，使用静态来避免函数调用间的整体多余运算。例如：在字符串文字中构建 <code>FName</code>。
</p></li><li class="Default"><p>注意热重载。最小化依赖性来减少迭代时间。无使用可能会在重载时发生改变的函数内联或模板。仅对在重载时保持不变的对象使用静态。
</p></li><li class="Default"><p>使用中间变量来简化复杂表达式。若含有复杂表达式，将其拆分为指定至中间变量的子表达式将更易理解（该子表达式的的命名描述了其在父表达式中的意义）。例如：
</p><pre class="prettyprint"><code>if ((Blah-&gt;BlahP-&gt;WindowExists-&gt;Etc &amp;&amp; Stuff) &amp;&amp;
    !(bPlayerExists &amp;&amp; bGameStarted &amp;&amp; bPlayerStillHasPawn &amp;&amp;
    IsTuesday())))
{
    DoSomething();
}</code></pre>
<p><code>应该替换成</code>
</p><pre class="prettyprint"><code>const bool bIsLegalWindow = Blah-&gt;BlahP-&gt;WindowExists-&gt;Etc &amp;&amp; Stuff;
const bool bIsPlayerDead = bPlayerExists &amp;&amp; bGameStarted &amp;&amp; bPlayerStillHasPawn &amp;&amp; IsTuesday();
if (bIsLegalWindow &amp;&amp; !bIsPlayerDead)
{
    DoSomething();
}</code></pre></li></ul><ul ><li class="Default"><p>指针与引用应仅含一个空格，该空格位于指针/引用右侧。使用 <strong>在文件中查找</strong> 可方便快速地找到特定类型的所有指针和引用。
</p></li><li class="Default"><p><em>使用：</em>
</p><pre class="prettyprint"><code>FShaderType&#42; Ptr</code></pre>
<p><em>Not these:</em>
</p><pre class="prettyprint"><code>FShaderType &#42;Ptr
FShaderType &#42; Ptr</code></pre></li></ul><ul ><li class="Default"><p>不允许隐藏变量。C++可在外部作用域隐藏变量，但此操作会导致语意不清。例如，该成员函数中含有三个可用 <code>计算</code> 变量：
</p><pre class="prettyprint"><code>class FSomeClass
{
public:
    void Func(const int32 Count)
    {
        for (int32 Count = 0; Count != 10; ++Count)
        {
            // Use Count
        }
    }

private:
    int32 Count;
}</code></pre></li></ul><ul ><li class="Default"><p>避免在函数调用中使用匿名文字。建议使用描述其含义的命名常量：
</p><pre class="prettyprint"><code>// 旧样式
Trigger(TEXT("Soldier"), 5, true);.

// 新样式
const FName ObjectName                = TEXT("Soldier");
const float CooldownInSeconds         = 5;
const bool bVulnerableDuringCooldown  = true;
Trigger(ObjectName, CooldownInSeconds, bVulnerableDuringCooldown);</code></pre>
<p>由于无需查找函数声明即可理解目的，因此此操作可协助普通读者快速理解。
</p></li></ul><h2 id="api设计指导方针">API设计指导方针</h2>
<ul ><li class="Default"><p>应避免使用 <code>布尔</code> 函数参数，切勿用于传递到函数的标签。其也拥有与前文提到匿名文字问题，但API利用更多行为扩展时，此类问题将成倍增加。相反，应优先使用列举（参见<a id="content_link" href="#强类型化列举" ><span>强类型化列举</span></a>章节中将列举用作标签的建议）：
</p><pre class="prettyprint"><code>// 旧样式
FCup&#42; MakeCupOfTea(FTea&#42; Tea, bool bAddSugar = false, bool bAddMilk = false, bool bAddHoney = false, bool bAddLemon = false);
FCup&#42; Cup = MakeCupOfTea(Tea, false, true, true);

// 新样式
enum class ETeaFlags
{
    None,
    Milk  = 0x01,
    Sugar = 0x02,
    Honey = 0x04,
    Lemon = 0x08
};
ENUM&#95;CLASS&#95;FLAGS(ETeaFlags)

FCup&#42; MakeCupOfTea(FTea&#42; Tea, ETeaFlags Flags = ETeaFlags::None);
FCup&#42; Cup = MakeCupOfTea(Tea, ETeaFlags::Milk &#124; ETeaFlags::Honey);</code></pre>
<p>此类形式可防止意外置换标签，避免意外在指针和整数参数中转换，而无需重复多余默认值，从而变得更加高效。<br />将 <code>布尔</code> 传递到类似setter（例如 void FWidget::SetEnabled(bool bEnabled)）的函数完整状态时，可使用 <code>布尔</code> 作为参数。如此设置发生变化，则使用重构。
</p></li><li class="Default"><p>避免过长的函数参数列表。如函数使用多个参数，则选择传递专属结构体：
</p><pre class="prettyprint"><code>// 旧样式
TUniquePtr&lt;FCup&#91;&#93;&gt; MakeTeaForParty(const FTeaFlags&#42; TeaPreferences, uint32 NumCupsToMake, FKettle&#42; Kettle, ETeaType TeaType = ETeaType::EnglishBreakfast, float BrewingTimeInSeconds = 120.0f);

// 新样式
struct FTeaPartyParams
{
    const FTeaFlags&#42; TeaPreferences       = nullptr;
    uint32           NumCupsToMake        = 0;
    FKettle&#42;         Kettle               = nullptr;
    ETeaType         TeaType              = ETeaType::EnglishBreakfast;
    float            BrewingTimeInSeconds = 120.0f;
};
TUniquePtr&lt;FCup&#91;&#93;&gt; MakeTeaForParty(const FTeaPartyParams&amp; Params);</code></pre></li></ul><ul ><li class="Default"><p>避免使用 <code>布尔</code> 和 `Fstring`` 重载函数，此操作可能导致意外行为：
</p><pre class="prettyprint"><code>void Func(const FString&amp; String);
void Func(bool bBool);

Func(TEXT("String")); // Calls the bool overload!</code></pre></li></ul><ul ><li class="Default"><p>接口类（前缀为"I"）固定为抽象，切不可拥有成员变量。只要接口为内联实现，其可包含非纯虚拟方法，甚至非虚拟或静态方法。
</p></li><li class="Default"><p>声明覆盖方法时应使用 <code>虚拟</code> 和 <code>覆盖</code> 关键字。若在派生类（此类在父类中覆盖虚幻函数）中声明虚幻函数，必须同时使用 <code>虚拟</code> 和 <code>覆盖</code> 关键字。例如：
</p><pre class="prettyprint"><code>class A
{
public:
    virtual void F() {}
};

class B : public A
{
public:
    virtual void F() override;
}</code></pre>
<div class="note">
	<p>由于最近新添 <code>覆盖</code> 关键字，许多现有代码并未遵守此规则。需在方便时将 <code>覆盖</code> 关键字添加至该代码。</p>
</div></li></ul><h2 id="平台特定代码">平台特定代码</h2>
<p>应固定抽取平台特定代码，并在正确命名的子目录中平台特定源文件内实现，例如：
</p><pre class="prettyprint"><code>Source/Runtime/Core/Private/&#91;PLATFORM&#93;/&#91;PLATFORM&#93;Memory.cpp</code></pre>
<p>通常应避免在名为[PLATFORM]的目录外，将 <code>PLATFORM&#95;&#91;<code>PLATFORM</code>&#93;</code> 的使用（例如 <code>PLATFORM&#95;XBOXONE</code>）添加到代码。
</p><p>相反，应扩展硬件抽象层，以添加静态函数，例如在FPlatformMisc中：
</p><pre class="prettyprint"><code>FORCEINLINE static int32 GetMaxPathLength()
{
    return 128;
}</code></pre>
<p>之后，平台可覆盖此函数，返回平台特定常量值，或使用平台API决定结果。
</p><p>如强制内联该函数，其将具有和使用定义时同样的性能特征。
</p><p>必须需使用定义时，应新建描述可应用到函数的特定属性的#define，例如 <code>PLATFORM&#95;USE&#95;PTHREADS</code>。在Platform.h中设置默认值，并覆盖平台（平台特定Platform.h文件中需要）的默认值。
</p><p>例如，在Platform.h中有：
</p><pre class="prettyprint"><code>#ifndef PLATFORM&#95;USE&#95;PTHREADS 
    #define PLATFORM&#95;USE&#95;PTHREADS 1
#endif</code></pre>
<p>Windows/WindowsPlatform.h有：
</p><pre class="prettyprint"><code>#define PLATFORM&#95;USE&#95;PTHREADS 0</code></pre>
<p>跨平台代码可直接使用该定义，无需知晓平台。
</p><pre class="prettyprint"><code>#if PLATFORM&#95;USE&#95;PTHREADS 
    #include "HAL/PThreadRunnableThread.h"
#endif</code></pre>
<p>理由：将引擎的平台特定细节集中化，平台特定源文件中可完全包含此类细节。此操作可便于维护多个平台的引擎，还可将代码移植到新平台，而无需在基本代码中查找平台特定定义。
</p><p>PS4、XboxOne和Nintendo Switch等NDA平台要求将平台代码保存在平台特定文件夹中。
</p><p>无论 <code>&#91;PLATFORM&#93;</code> 子目录是否显示，应确保编译并运行代码。换言之，跨平台代码不可依赖平台特定代码。
</p>
																	</div>
					<!-- End of Markdown converted page content -->
				</div>
												<div id="pageTags">
				<div class="title">标签</div>
					<div>
					<div class="keyword_tag_filter"><a id="tag_link" href="../../../SiteIndex/index.html?tags=coding%20standard">coding standard</a></div>
					</div>
				</div>
								<div id="recommendations"></div>			</div>
						  									<div id="announcement">
			<div style="display:inline-block;margin:5px;">
				欢迎帮助改进虚幻引擎文档！请告诉我们该如何更好地为您服务。
			</div>
			<div style="margin:5px;display:inline-block;">
				<div class="btn action" style="margin-top:-6px;display:inline-block;" onclick="$('#announcement').hide();window.open('https://epicgames.questionpro.com/t/AP9dGZkjp4');createCookie('announcement-read', new Date().getTime(), 30);">填写问卷调查</div>
				<div class="btn btn-default" style="margin-top:-6px;display:inline-block;" onclick="$('#announcement').hide();createCookie('announcement-read', new Date().getTime(), 30);">取消</div>
			</div>
			<div class="btn-close" style="position:absolute;right:5px;top:10px;padding:3px;width:14px;height:14px;" onclick="$('#announcement').hide();"></div>
			</div>
					</div>
	</div></body>

<!-- Mirrored from docs.unrealengine.com/4.26/zh-CN/ProductionPipelines/DevelopmentSetup/CodingStandard/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 17 Jan 2024 11:10:05 GMT -->
</html>
