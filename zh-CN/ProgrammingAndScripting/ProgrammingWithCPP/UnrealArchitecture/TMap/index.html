<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">

<!-- Mirrored from docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 17 Jan 2024 12:21:40 GMT -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="../../../../../Include/Javascript/common_zh-CN.js" type="text/javascript"></script>
	<script type="text/javascript">
		var time = new Date(0);
		var preview = false;
		var relativeHTMLPath = "https://docs.unrealengine.com/4.26/";
				var pageid = 0;
				var heroimage = "";
				var lang = "zh-CN";
				var basePath = document.location.pathname.substring(0, document.location.pathname.indexOf('/' + lang + '/') + lang.length + 1);
		document.write('<base href="' +  encodeURI(basePath) + '/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/" />');
				var udnCSS = '../../../../../Include/CSS/udn_public.css';
		var udnLangCSS = '';
				udnLangCSS = './../../../../../Include/CSS/udn_public_CN.css">';
				var udnOverrideCSS = '../../../../../Include/CSS/skin_overrides.css';
		var udnOverrideDarkCSS = '../../../../../Include/CSS/skin_overrides_dark.css';
		var fancyboxCSS = '../../../../../Include/CSS/jquery.fancybox.css';
		var jqueryuiCSS = '../../../../../Include/CSS/jquery-ui.min.css';
		var qtipCSS = '../../../../../Include/CSS/jquery.qtip.css';
		var prettifyCSS = '../../../../../Include/CSS/prettify.css';
		var navbarCSS = '../../../../../Include/CSS/navBar.css';
		var twentytwentyCSS = '../../../../../Include/CSS/twentytwenty.css';
		var recommendationsCSS = '../../../../../Include/CSS/jquery.recommendations.css';
	</script>
    <title>TMap | 虚幻引擎文档</title>
    	    <meta name=viewport content="width=device-width, initial-scale=1" />
	<meta http-equiv="Cache-control" content="no-store">
    <script  src="../../../../../Include/Javascript/CustomEvent.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/jquery-3.4.0.min.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/udn.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/udn_extras.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/jquery-ui.min.js" type="text/javascript"></script>
	    <script  src="../../../../../Include/Javascript/informational.js" type="text/javascript"></script>
	    <script  src="../../../../../Include/Javascript/jquery.fancybox.pack.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/jquery.qtip.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/prettify.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/jquery.slimscroll.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/jquery.event.move.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/jquery.twentytwenty.js" type="text/javascript"></script>
    <script  src="../../../../../Include/Javascript/lazysizes.min.js" type="text/javascript"></script>
	    <script  src="../../../../../Include/Javascript/jquery.recommendations.js" type="text/javascript"></script>
	
    <link async rel="icon" href="../../../../../../favicon.png" type="image/x-icon" />
    <link async rel="shortcut icon" href="../../../../../../favicon.png" type="image/x-icon" />
    <link async href="../../../../../Include/Images/touch_icon.png" rel="apple-touch-icon" />
    <link async href="../../../../../Include/Images/touch_icon_114.png" sizes="114x114" rel="apple-touch-icon" />    
		<script  src="../../../../../Include/Javascript/CollapsibleLists.js" type="text/javascript"></script>
	<script  src="../../../../../Include/Javascript/navigationBarUI.js"></script>
	<script  src="../../../../../Include/Javascript/navigationBar.js"></script>
		
	<link rel="alternate" href="https://docs.unrealengine.com/latest/en-US/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/" hreflang="x-default" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/" hreflang="zh-CN" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/ja/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/" hreflang="ja" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/ko/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/" hreflang="ko" />

	<meta name="redirect" content="Programming/UnrealArchitecture/TMap" />
<meta name="intsourcechangelist" content="14103881" />
<meta name="title" content="TMap" />
<meta name="description" content="TMap主要由两个类型定义（一个键类型和一个值类型），以关联对的形式存储在映射中。" />
<meta name="availability" content="Public" />
<meta name="version" content="4.14" />
<meta name="parent" content="ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture" />
<meta name="related" content="BuildingWorlds/LevelEditor/Details/Properties/Map" />
<meta name="crumbs" content="%ROOT%,ProgrammingAndScripting,ProgrammingAndScripting/ProgrammingWithCPP,ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture" />

	<meta name="twitter:card" content="summary_large_image" />
	<meta property="og:title" content="TMap" />
	<meta property="og:description" content="TMap主要由两个类型定义（一个键类型和一个值类型），以关联对的形式存储在映射中。 " />
		<meta property="og:image" content="" />
	</head>
<body id="webbgThree" style="visibility: hidden;" onload="document.body.style.visibility='visible';">
			<script>window.__tracking_base = 'https://tracking.unrealengine.com/';</script>
	<script src="../../../../../../../tracking.unrealengine.com/tracking.js" async></script>    <div id="webThree">
				<div id="page_head">

			<edc-navigation blackListLangCodes='["de-de","es-es","es-mx","fr-fr","it-it","pt-br","ru-ru","pl-pl","tr-tr"]' locale="zh-CN" ></edc-navigation>
						<div id="pagenav">
				<div class="crumbs" id="crumbs">
<span id="versionContainer">
	<span id="versionSelect" class="btn btn-version" onclick="ToggleMenu($('#versionMenu'), $(this));"></span>
	<div id="versionMenu">
		<div id="4_26" data-version="4.26" class="btn btn-select" onclick="createCookie('version', '4.26', 365);SwitchVersion('4.26');">Unreal Engine 4.26 Documentation</div>
		<div id="4_27" data-version="4.27" class="btn btn-select" onclick="createCookie('version', '4.27', 365);SwitchVersion('4.27');">Unreal Engine 4.27 Documentation</div>
		<div id="5_0" data-version="5.0" class="btn btn-select" onclick="createCookie('version', '5.0', 365);SwitchVersion('5.0');">Unreal Engine 5.0 Documentation</div>
		<div id="5_1" data-version="5.1" class="btn btn-select" onclick="createCookie('version', '5.1', 365);SwitchVersion('5.1');">Unreal Engine 5.1 Documentation</div>
		<div id="5_2" data-version="5.2" class="btn btn-select" onclick="createCookie('version', '5.2', 365);SwitchVersion('5.2');">Unreal Engine 5.2 Documentation</div>
		<div id="5_3" data-version="5.3" class="btn btn-select" onclick="createCookie('version', '5.3', 365);SwitchVersion('5.3');">Unreal Engine 5.3 Documentation</div>
	</div>
</span>
	<span class="separator">></span> <a id="parent_link" href="../../../index.html">编程和脚本编写</a>

	<span class="separator">></span> <a id="parent_link" href="../../index.html">编程指南</a>

	<span class="separator">></span> <a id="parent_link" href="../index.html">游戏逻辑编程</a>

<span class="separator">></span> <span id="page">TMap</span>
</div>				<div id="pageNavRight">
								<!-- Start of Search -->
												<div id="search_container">
					<form name="bodySearch" method="get" action="https://www.unrealengine.com/zh-CN/bing-search" onsubmit="return validateSearch()">
						<input type="image" src="../../../../../Include/Images/search_box_icon.png" class="searchbutton"/>
						<input type="hidden" name="filter" value="文档" />
						<input type="text" name="keyword" placeholder="搜索文档……" class="searchbox" autocomplete="off"/>
					</form>
				</div>
								<!-- End of Search -->
				<div id="skinContainer">
	<div id="skinSelect" class="btn btn-skin" onclick="ToggleMenu($('#skinMenu'), $(this));"></div>
	<div id="skinMenu">
		<div id="light" class="btn btn-select" onclick="createCookie('skin', 'light', 365);location.reload();">Light Theme</div>
		<div id="dark" class="btn btn-select" onclick="createCookie('skin', 'dark', 365);location.reload();">Dark Theme</div>
	</div>
</div>				</div>
			</div>
		</div>						<div id="navWrapper">
			<div id="nav-filter-container">
				<div id="nav-filter-inner">
					<form>
						<input type="text" placeholder="Filter pages..." id="nav-filter" onchange="clearTimeout(filterTimer); filterTimer = setTimeout(updateNavTreeFilter,250, this.value);if(this.value.length == 0){$('#filter-clear').hide();}else{$('#filter-clear').show();}" onkeypress="this.onchange();" onpaste="this.onchange();" oninput="this.onchange();" />
						<button class="close-icon" id="filter-clear" type="reset" onclick="clearTimeout(filterTimer); filterTimer = setTimeout(updateNavTreeFilter,250, '');$(this).hide();"></button>
					</form>
				</div>
			</div>
			<nav id="navPanel">
			</nav>
			<div id="navigation" title="Click to toggle navigation menu"><span>></span></div>
		</div>		
		<div id="splitter">
		</div>
				<div id="contentContainer">
										<div id="pagedefault">
				<div id="product-banner">
	<div id="product-logo"></div>
</div>				<div id="pagecontainer" style="padding-right:0px;">
					<!-- Start of Markdown converted page content -->
																				<div class="hero  ">
						<div class="imgContainer"><img src="#" /></div>						<div class="info">
							<div id="pageTitle">
								<h1 id="H1TitleId">TMap</h1>
							</div>	
							<h2 >TMap主要由两个类型定义（一个键类型和一个值类型），以关联对的形式存储在映射中。 </h2>
							<div id="access">
								<div class="accessContainer">
																																			</div>
							</div>
						</div>
					</div>
																				<div id="maincol">
						<div class="togglesection" id="osContainer">
	<div class="normaltitle">
		<p>Choose your operating system:</p>
	</div><div class="toggleButtons">
		<div class="btn btn-default btn-toggle OS windows" id="windows" onclick="setSelector('OS', 'windows');">
			<p>Windows</p>
		</div>
		<div class="btn btn-default btn-toggle OS mac" id="mac" onclick="setSelector('OS', 'mac');">
			<p>macOS</p>
		</div>
		<div class="btn btn-default btn-toggle OS linux" id="linux" onclick="setSelector('OS', 'linux');">
			<p>Linux</p>
		</div>
	</div>
</div>																		<div id="seeAlso">
	<div style="position:relative;">
		<div id="title">参见</div>
		<div id="pageList">
			<ul>
								<li>
					<p>
						<a id="related_link" href="../../../../BuildingWorlds/LevelEditor/Details/Properties/Map/index.html" title="两个相关属性的动态列表。">Map控制选项</a>
					</p>
				</li>
							</ul>
		</div>
	</div>
</div>
																														<div class="toc">
<div style="position:relative;">
    <div class="title">
    本页面的内容
    </div>
<div id="tocScroll">
    <ul>
	    		    			    <li id="">
	<p><a id="toc_link" href="#tmap">TMap</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#创建和填充映射">创建和填充映射</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#迭代">迭代</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#查询">查询</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#移除">移除</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#排序">排序</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#运算符">运算符</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#slack">Slack</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#keyfuncs">KeyFuncs</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#其他">其他</a></p>
	</li>		    	        </ul>
</div>
</div>
</div>
<p>继 <code>TArray</code> 之后，<strong>虚幻引擎4</strong>（UE4）中最常用的容器是 <code>TMap</code>。<code>TMap</code> 与 <code>TSet</code> 类似，它们的结构均基于对键进行散列运算。但与 <code>TSet</code> 不同的是，此容器将数据存储为键值对（<code>TPair&lt;KeyType, ValueType&gt;</code>），只将键用于存储和获取。
</p><p>映射有两种类型：<code>TMap</code> 和 <code>TMultiMap</code>。两者之间的不同点是，<code>TMap</code> 中的键是唯一的，而`TMultiMap<code> 可存储多个相同的键。在 </code>TMap<code> 中添加新的键值时，若所用的键与原有的对相同，新对将替换原有的对。在 </code>TMultiMap` 中，容器可以同时存储新对和原有的对。
</p><h2 id="tmap">TMap</h2>
<p>在 <code>TMap</code> 中，键值对被视为映射的元素类型，相当于每一对都是个体对象。在本文中，元素就意味着键值对，而各个组件就被称作元素的键或元素的值。元素类型实际上是 <code>TPair&lt;KeyType, ElementType&gt;</code>，但很少需要直接引用 <code>TPair</code> 类型。
</p><p>和 <code>TArray</code> 一样，<code>TMap</code> 也是同质容器，就是说它所有元素的类型都应完全相同。<code>TMap</code> 也是值类型，支持通常的复制、赋值和析构函数运算，以及它的元素的强所有权。在映射被销毁时，它的元素都会被销毁。键和值也必须为值类型。
</p><p><code>TMap</code> 是散列容器，这意味着键类型必须支持 <code>GetTypeHash</code> 函数，并提供 <code>运算符==</code> 来比较各个键是否等值。稍后将详细介绍散列。
</p><p><code>TMap</code> 也可使用任选分配器来控制内存分配行为。但不同于 <code>TArray</code>，这些是集合分配器，而不是 <code>FHeapAllocator</code> 和 <code>TInlineAllocator</code> 之类的标准UE4分配器。集合分配器（`TSetAllocator`类）定义映射应使用的散列桶数量，以及应使用哪个标准UE4分配器来存储散列和元素。
</p><p><code>KeyFuncs</code> 是最后一个 <code>TMap</code> 模板参数，该参数告知映射如何从元素类型获取键，如何比较两个键是否相等，以及如何对键进行散列计算。这些参数有默认值，它们只会返回对键的引用，使用 <code>运算符==</code> 确定相等性，并调用非成员 <code>GetTypeHash</code> 函数进行散列计算。如果您的键类型支持这些函数，可使用它作为映射键，不需要提供自定义 <code>KeyFuncs</code>。
</p><p>与 <code>TArray</code> 不同的是，内存中 <code>TMap</code> 元素的相对排序既不可靠也不稳定，对这些元素进行迭代很可能会使它们返回的顺序和它们添加的顺序有所不同。这些元素也不太可能在内存中连续排列。映射的支持数据结构是稀疏数组，这种数组可有效支持元素之间的空位。当元素从映射中被移除时，稀疏数组中就会出现空位。将新的元素添加到数组可填补这些空位。但是，即便 <code>TMap</code> 不会打乱元素来填补空位，指向映射元素的指针仍然可能失效，因为如果存储器被填满，又添加了新的元素，整个存储可能会重新分配。
</p><h2 id="创建和填充映射">创建和填充映射</h2>
<p><code>TMap</code> 的创建方法如下：
</p><pre class="prettyprint"><code>TMap&lt;int32, FString&gt; FruitMap;</code></pre>
<p><code>FruitMap</code> 现在是一个字符串的空 <code>TMap</code>，该字符串由整数键标识。我们既没有指定分配器，也没有指定 <code>KeyFuncs</code>，所以映射将执行标准的堆分配，使用 <code>运算符==</code> 对键进行对比（<code>int32</code> 类型），并使用 <code>GetTypeHash</code> 进行散列运算。此时没有分配任何内存。
</p><p>填充映射的标准方法是调用带一个键和值的 <code>Add</code> 函数：
</p><pre class="prettyprint"><code>FruitMap.Add(5, TEXT("Banana"));
FruitMap.Add(2, TEXT("Grapefruit"));
FruitMap.Add(7, TEXT("Pineapple"));
// FruitMap == &#91;
//  { Key:5, Value:"Banana"     },
//  { Key:2, Value:"Grapefruit" },
//  { Key:7, Value:"Pineapple"  }
// &#93;</code></pre>
<p><div class="note">
	<p>此处的元素按插入顺序排列，但不保证这些元素在内存中实际保留此排序。如果是新的映射，可能会保留插入排序，但插入和删除的次数越多，新元素不出现在末尾的可能性就越大。</p>
</div>
</p><p>这不是 <code>TMultiMap</code>，所以各个键都必定是唯一。如果尝试添加重复键，将发生以下情况：
</p><pre class="prettyprint"><code>FruitMap.Add(2, TEXT("Pear"));
// FruitMap == &#91;
//  { Key:5, Value:"Banana"    },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" }
// &#93;</code></pre>
<p>映射仍然包含3个元素，但之前键值为2的"Grapefruit"已被"Pear"替代。
</p><p><code>Add</code> 函数可接受不带值的键。调用此重载后的 <code>Add</code> 时，值将被默认构建：
</p><pre class="prettyprint"><code>FruitMap.Add(4);
// FruitMap == &#91;
//  { Key:5, Value:"Banana"    },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:""          }
// &#93;</code></pre>
<p>和 <code>TArray</code> 一样，还可使用 <code>Emplace</code> 代替 <code>Add</code>，防止插入映射时创建临时文件：
</p><pre class="prettyprint"><code>FruitMap.Emplace(3, TEXT("Orange"));
// FruitMap == &#91;
//  { Key:5, Value:"Banana"    },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:""          },
//  { Key:3, Value:"Orange"    }
// &#93;</code></pre>
<p>此处直接将键和值传递给了各自的构造函数。这对 <code>int32</code> 键实际上没有影响，但避免了为该值创建临时 <code>FString</code>。与 <code>TArray</code> 不同的是，只能通过单一参数构造函数将元素安放到映射中。
</p><p>也可使用 <code>Append</code> 函数合并映射，将一个映射的所有元素移至另一个映射：
</p><pre class="prettyprint"><code>TMap&lt;int32, FString&gt; FruitMap2;
FruitMap2.Emplace(4, TEXT("Kiwi"));
FruitMap2.Emplace(9, TEXT("Melon"));
FruitMap2.Emplace(5, TEXT("Mango"));
FruitMap.Append(FruitMap2);
// FruitMap == &#91;
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     }
// &#93;
// FruitMap2 is now empty.</code></pre>
<p>在上面的示例中，生成的映射和使用 <code>Add</code> 或 <code>Emplace</code> 逐个添加 <code>FruitMap2</code> 的元素相同，在该过程完成时会清空 <code>FruitMap2</code>。这意味着如果 <code>FruitMap2</code> 中任何元素的键与 <code>FruitMap</code> 中原有元素的键相同，就会取代该元素。
</p><p>如果用 <code>UPROPERTY</code> 宏和一个可编辑的关键词（<code>EditAnywhere</code>、<code>EditDefaultsOnly</code> 或 <code>EditInstanceOnly</code>）标记 <code>TMap</code>，即可<a id="content_link" href="../../../../BuildingWorlds/LevelEditor/Details/Properties/Map/index.html" ><span>在编辑器中添加和编辑元素</span></a>。
</p><pre class="prettyprint"><code>UPROPERTY(Category = MapsAndSets, EditAnywhere)
TMap&lt;int32, FString&gt; FruitMap;</code></pre>
<h2 id="迭代">迭代</h2>
<p><code>TMaps</code> 的迭代类似于 <code>TArrays</code>。可使用C++的设置范围功能，注意元素类型是 <code>TPair</code>：
</p><pre class="prettyprint"><code>for (auto&amp; Elem :FruitMap)
{
    FPlatformMisc::LocalPrint(
        &#42;FString::Printf(
            TEXT("(%d, \"%s\")\n"),
            Elem.Key,
            &#42;Elem.Value
        )
    );
}
// Output:
// (5, "Mango")
// (2, "Pear")
// (7, "Pineapple")
// (4, "Kiwi")
// (3, "Orange")
// (9, "Melon")</code></pre>
<p>也可以用 <code>CreateIterator</code> 和 <code>CreateConstIterators</code> 函数来创建迭代器。<code>CreateIterator</code> 返回拥有读写访问权限的迭代器，而 <code>CreateConstIterator</code> 返回拥有只读访问权限的迭代器。无论哪种情况，均可用这些迭代器的 <code>Key</code> 和 <code>Value</code> 来检查元素。使用迭代器显示"fruit"范例映射将产生如下结果：
</p><pre class="prettyprint"><code>for (auto It = FruitMap.CreateConstIterator(); It; ++It)
{
    FPlatformMisc::LocalPrint(
        &#42;FString::Printf(
            TEXT("(%d, \"%s\")\n"),
            It.Key(),   // same as It-&gt;Key
            &#42;It.Value() // same as &#42;It-&gt;Value
        )
    );
}</code></pre>
<h2 id="查询">查询</h2>
<p>调用 <code>Num</code> 函数即可查询映射中保存的元素数量：
</p><pre class="prettyprint"><code>int32 Count = FruitMap.Num();
// Count == 6</code></pre>
<p>要确定映射是否包含特定键，可按下方所示调用 <code>Contains</code> 函数：
</p><pre class="prettyprint"><code>bool bHas7 = FruitMap.Contains(7);
bool bHas8 = FruitMap.Contains(8);
// bHas7 == true
// bHas8 == false</code></pre>
<p>如果知道映射中存在某个特定键，可使用 <code>运算符&#91;&#93;</code> 查找相应值，将键用作索引。使用非常量映射执行该操作将返回非常量引用，使用常量映射将返回常量引用。
</p><p><code>运算符&#91;&#93;</code></p><pre class="prettyprint"><code>FString Val7 = FruitMap&#91;7&#93;;
// Val7 == "Pineapple"
FString Val8 = FruitMap&#91;8&#93;;
// Assert!</code></pre>
<p>如果不确定映射中是否包含某个键，可使用 <code>Contains</code> 函数和 <code>运算符&#91;&#93;</code> 进行检查。但这并非理想的方法，因为同一键需要进行两次查找才能获取成功。使用 <code>Find</code> 函数查找一次即可完成这些行为。如果映射包含该键，<code>Find</code> 将返回指向元素数值的指针。如果映射不包含该键，则返回null。在常量映射上调用 <code>Find</code>，返回的指针也将为常量。
</p><pre class="prettyprint"><code>FString&#42; Ptr7 = FruitMap.Find(7);
FString&#42; Ptr8 = FruitMap.Find(8);
// &#42;Ptr7 == "Pineapple"
//  Ptr8 == nullptr</code></pre>
<p>或为了确保查询的结果有效，可使用 <code>FindOrAdd</code> 或 <code>FindRef</code>。<code>FindOrAdd</code> 将返回对与给定键关联的值的引用。如果映射中不存在该键，<code>FindOrAdd</code> 将返回新创建的元素（使用给定键和默认构建值），该元素也会被添加到映射。<code>FindOrAdd</code> 可修改映射，因此仅适用于非常量映射。不要被名称迷惑，<code>FindRef</code> 会返回与给定键关联的值副本；若映射中未找到给定键，则返回默认构建值。<code>FindRef</code> 不会创建新元素，因此既可用于常量映射，也可用于非常量映射。即使在映射中找不到键，<code>FindOrAdd</code> 和 <code>FindRef</code> 也会成功运行，因此无需执行常规的安全规程（如提前检查 <code>Contains</code> 或对返回值进行空白检查）就可安全地调用。
</p><pre class="prettyprint"><code>FString&amp; Ref7 = FruitMap.FindOrAdd(7);
// Ref7     == "Pineapple"
// FruitMap == &#91;
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     }
// &#93;
FString&amp; Ref8 = FruitMap.FindOrAdd(8);
// Ref8     == ""
// FruitMap == &#91;
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     },
//  { Key:8, Value:""          }
// &#93;

FString Val7 = FruitMap.FindRef(7);
FString Val6 = FruitMap.FindRef(6);
// Val7     == "Pineapple"
// Val6     == ""
// FruitMap == &#91;
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     },
//  { Key:8, Value:""          }
// &#93;</code></pre>
<div class="note">
	<p>和示例中初始化 <code>Ref8</code> 时一样，<code>FindOrAdd</code> 可向映射添加新条目，因此之前获得的指针（来自 <code>Find</code>）或引用（来自 <code>FindOrAdd</code>）可能会无效。如果映射的后端存储需要扩展以容纳新元素，会执行分配内存和移动现有数据的添加操作，从而导致这一结果。以上示例中，在调用 <code>FindOrAdd(8)</code> 之后，<code>Ref7</code> 可能会紧随 <code>Ref8</code> 失效。</p>
</div><p><code>FindKey</code> 函数执行逆向查找，这意味着提供的值与键匹配，并返回指向与所提供值配对的第一个键的指针。搜索映射中不存在的值将返回空键。
</p><pre class="prettyprint"><code>const int32&#42; KeyMangoPtr   = FruitMap.FindKey(TEXT("Mango"));
const int32&#42; KeyKumquatPtr = FruitMap.FindKey(TEXT("Kumquat"));
// &#42;KeyMangoPtr   == 5
//  KeyKumquatPtr == nullptr</code></pre>
<div class="note">
	<p>按值查找比按键查找慢（线性时间）。这是因为映射按键排序，而非按值排序。此外，如果映射有多个具有相同值的键，<code>FindKey</code> 可返回其中任一键。</p>
</div><p><code>GenerateKeyArray</code> 和 <code>GenerateValueArray</code> 分别使用所有键和值的副本来填充 <code>TArray</code>。在这两种情况下，都会在填充前清空所传递的数组，因此产生的元素数量始终等于映射中的元素数量。
</p><pre class="prettyprint"><code>TArray&lt;int32&gt;   FruitKeys;
TArray&lt;FString&gt; FruitValues;
FruitKeys.Add(999);
FruitKeys.Add(123);
FruitMap.GenerateKeyArray  (FruitKeys);
FruitMap.GenerateValueArray(FruitValues);
// FruitKeys   == &#91; 5,2,7,4,3,9,8 &#93;
// FruitValues == &#91; "Mango","Pear","Pineapple","Kiwi","Orange",
//                  "Melon","" &#93;</code></pre>
<h2 id="移除">移除</h2>
<p>从映射中移除元素的方法是使用 <code>Remove</code> 函数并提供要移除元素的键。返回值是被移除元素的数量。如果映射不包含与键匹配的元素，则返回值可为零。
</p><pre class="prettyprint"><code>FruitMap.Remove(8);
// FruitMap == &#91;
//  { Key:5, Value:"Mango"     },
//  { Key:2, Value:"Pear"      },
//  { Key:7, Value:"Pineapple" },
//  { Key:4, Value:"Kiwi"      },
//  { Key:3, Value:"Orange"    },
//  { Key:9, Value:"Melon"     }
// &#93;</code></pre>
<div class="note">
	<p>移除元素将在数据结构（在Visual Studio的观察窗口中可视化映射时可看到）中留下空位，但为保证清晰度，此处省略。</p>
</div><p><code>FindAndRemoveChecked</code> 函数可用于从映射移除元素并返回其值。名称的"已检查"部分表示若键不存在，映射将调用 <code>check</code>（UE4中等同于 <code>assert</code>）。
</p><pre class="prettyprint"><code>FString Removed7 = FruitMap.FindAndRemoveChecked(7);
// Removed7 == "Pineapple"
// FruitMap == &#91;
//  { Key:5, Value:"Mango"  },
//  { Key:2, Value:"Pear"   },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// &#93;

FString Removed8 = FruitMap.FindAndRemoveChecked(8);
// Assert!</code></pre>
<p><code>RemoveAndCopyValue</code> 函数的作用与 <code>Remove</code> 相似，不同点是会将已移除元素的值复制到引用参数。如果映射中不存在指定的键，则输出参数将保持不变，函数将返回 <code>false</code>。
</p><pre class="prettyprint"><code>FString Removed;
bool bFound2 = FruitMap.RemoveAndCopyValue(2, Removed);
// bFound2  == true
// Removed  == "Pear"
// FruitMap == &#91;
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// &#93;
bool bFound8 = FruitMap.RemoveAndCopyValue(8, Removed);
// bFound8  == false
// Removed  == "Pear", i.e. unchanged
// FruitMap == &#91;
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// &#93;</code></pre>
<p>最后，使用 <code>Empty</code> 或 <code>Reset</code> 函数可将映射中的所有元素移除。
</p><pre class="prettyprint"><code>TMap&lt;int32, FString&gt; FruitMapCopy = FruitMap;
// FruitMapCopy == &#91;
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" },
//  { Key:9, Value:"Melon"  }
// &#93;

FruitMapCopy.Empty();       // We could also have called Reset() here.
// FruitMapCopy == &#91;&#93;</code></pre>
<p><code>Empty</code> 和 <code>Reset</code> 相似，但 <code>Empty</code> 可采用参数指示映射中保留的slack量，而 <code>Reset</code></p><h2 id="排序">排序</h2>
<p><code>TMap</code> 可以进行排序。排序后，迭代映射会以排序的顺序显示元素，但下次修改映射时，排序可能会发生变化。排序是不稳定的，因此等值元素在MultiMap中可能以任何顺序出现。
</p><p>使用 <code>KeySort</code> 或 <code>ValueSort</code> 函数可分别按键和值进行排序。两个函数均使用二元谓词来进行排序：
</p><pre class="prettyprint"><code>FruitMap.KeySort(&#91;&#93;(int32 A, int32 B) {
    return A &gt; B; // sort keys in reverse
});
// FruitMap == &#91;
//  { Key:9, Value:"Melon"  },
//  { Key:5, Value:"Mango"  },
//  { Key:4, Value:"Kiwi"   },
//  { Key:3, Value:"Orange" }
// &#93;

FruitMap.ValueSort(&#91;&#93;(const FString&amp; A, const FString&amp; B) {
    return A.Len() &lt; B.Len(); // sort strings by length
});
// FruitMap == &#91;
//  { Key:4, Value:"Kiwi"   },
//  { Key:5, Value:"Mango"  },
//  { Key:9, Value:"Melon"  },
//  { Key:3, Value:"Orange" }
// &#93;</code></pre>
<h2 id="运算符">运算符</h2>
<p>和 <code>TArray</code> 一样，<code>TMap</code> 是常规值类型，可通过标准复制构造函数或赋值运算符进行复制。因为映射严格拥有其元素，复制映射的操作是深层的，所以新的映射将拥有其自己的元素副本。
</p><pre class="prettyprint"><code>TMap&lt;int32, FString&gt; NewMap = FruitMap;
NewMap&#91;5&#93; = "Apple";
NewMap.Remove(3);
// FruitMap == &#91;
//  { Key:4, Value:"Kiwi"   },
//  { Key:5, Value:"Mango"  },
//  { Key:9, Value:"Melon"  },
//  { Key:3, Value:"Orange" }
// &#93;
// NewMap == &#91;
//  { Key:4, Value:"Kiwi"  },
//  { Key:5, Value:"Apple" },
//  { Key:9, Value:"Melon" }
// &#93;</code></pre>
<p><code>TMap</code> 支持移动语义，使用 <code>MoveTemp</code> 函数可调用这些语义。在移动后，源映射必定为空：
</p><pre class="prettyprint"><code>FruitMap = MoveTemp(NewMap);
// FruitMap == &#91;
//  { Key:4, Value:"Kiwi"  },
//  { Key:5, Value:"Apple" },
//  { Key:9, Value:"Melon" }
// &#93;
// NewMap == &#91;&#93;</code></pre>
<h2 id="slack">Slack</h2>
<p>Slack是不包含元素的已分配内存。调用 <code>Reserve</code> 可分配内存，无需添加元素；通过非零slack参数调用 <code>Reset</code> 或 <code>Empty</code> 可移除元素，无需将其使用的内存取消分配。Slack优化了将新元素添加到映射的过程，因为可以使用预先分配的内存，而不必分配新内存。它在移除元素时也十分实用，因为系统不需要将内存取消分配。在清空希望用相同或更少的元素立即重新填充的映射时，此方法尤其有效。
</p><div class="note">
	<p><code>TMap</code> 不像 <code>TArray</code> 中的 <code>Max</code> 函数那样可以检查预分配元素的数量。</p>
</div><p>在下列代码中，<code>Reserve</code> 函数预先分配映射，最多可包含10个元素。
</p><pre class="prettyprint"><code>FruitMap.Reserve(10);
for (int32 i = 0; i &lt; 10; ++i)
{
    FruitMap.Add(i, FString::Printf(TEXT("Fruit%d"), i));
}
// FruitMap == &#91;
//  { Key:9, Value:"Fruit9" },
//  { Key:8, Value:"Fruit8" },
//  ...
//  { Key:1, Value:"Fruit1" },
//  { Key:0, Value:"Fruit0" }
// &#93;</code></pre>
<p>使用 <code>Collapse</code> 和 <code>Shrink</code> 函数可移除 <code>TMap</code> 中的全部slack。<code>Shrink</code> 将从容器的末端移除所有slack，但这会在中间或开始处留下空白元素。
</p><pre class="prettyprint"><code>for (int32 i = 0; i &lt; 10; i += 2)
{
    FruitMap.Remove(i);
}
// FruitMap == &#91;
//  { Key:9, Value:"Fruit9" },
//  &lt;invalid&gt;,
//  { Key:7, Value:"Fruit7" },
//  &lt;invalid&gt;,
//  { Key:5, Value:"Fruit5" },
//  &lt;invalid&gt;,
//  { Key:3, Value:"Fruit3" },
//  &lt;invalid&gt;,
//  { Key:1, Value:"Fruit1" },
//  &lt;invalid&gt;
// &#93;
FruitMap.Shrink();
// FruitMap == &#91;
//  { Key:9, Value:"Fruit9" },
//  &lt;invalid&gt;,
//  { Key:7, Value:"Fruit7" },
//  &lt;invalid&gt;,
//  { Key:5, Value:"Fruit5" },
//  &lt;invalid&gt;,
//  { Key:3, Value:"Fruit3" },
//  &lt;invalid&gt;,
//  { Key:1, Value:"Fruit1" }
// &#93;</code></pre>
<p>在上述代码中，<code>Shrink</code> 只删除了一个无效元素，因为末端只有一个空元素。要移除所有slack，首先应调用 <code>Compact</code> 函数，将空白空间组合在一起，为调用 <code>Shrink</code> 做好准备。
</p><pre class="prettyprint"><code>FruitMap.Compact();
// FruitMap == &#91;
//  { Key:9, Value:"Fruit9" },
//  { Key:7, Value:"Fruit7" },
//  { Key:5, Value:"Fruit5" },
//  { Key:3, Value:"Fruit3" },
//  { Key:1, Value:"Fruit1" },
//  &lt;invalid&gt;,
//  &lt;invalid&gt;,
//  &lt;invalid&gt;,
//  &lt;invalid&gt;
// &#93;
FruitMap.Shrink();
// FruitMap == &#91;
//  { Key:9, Value:"Fruit9" },
//  { Key:7, Value:"Fruit7" },
//  { Key:5, Value:"Fruit5" },
//  { Key:3, Value:"Fruit3" },
//  { Key:1, Value:"Fruit1" }
// &#93;</code></pre>
<h2 id="keyfuncs">KeyFuncs</h2>
<p>只要类型具有 <code>运算符==</code> 和非成员 <code>GetTypeHash</code> 重载，就可用作 <code>TMap</code> 的键类型，不需要任何更改。但是，您可能需要将类型用作键，而不重载这些函数。在这些情况下，可对 <code>KeyFuncs</code> 进行自定义。为键类型创建 <code>KeyFuncs</code>，必须定义两个typedef和三个静态函数，如下所示：
</p><ul ><li class="Default"><p><code>KeyInitType</code> —— 用于传递键的类型。
</p></li><li class="Default"><p><code>ElementInitType</code> —— 用于传递元素的类型。
</p></li><li class="Default"><p><code>KeyInitType GetSetKey(ElementInitType Element)</code>——返回元素的键。
</p></li><li class="Default"><p><code>bool Matches(KeyInitType A, KeyInitType B)</code> —— 如果 <code>A</code> 和 <code>B</code> 等值将返回 <code>true</code>，否则返回 <code>false</code>。
</p></li><li class="Default"><p><code>uint32 GetKeyHash(KeyInitType Key)</code> —— 返回 <code>Key</code> 的散列值。
</p></li></ul><p><code>KeyInitType</code> 和 <code>ElementInitType</code> 是键类型和值类型的常规传递约定的typedef。它们通常为浅显类型的一个值，和非浅显类型的一个常量引用。请记住，映射的元素类型是 <code>TPair</code>。
</p><p>自定义 <code>KeyFuncs</code> 的示例可能如下所示：
</p><pre class="prettyprint"><code>struct FMyStruct
{
    // String which identifies our key
    FString UniqueID;

    // Some state which doesn't affect struct identity
    float SomeFloat;

    explicit FMyStruct(float InFloat)
        :UniqueID (FGuid::NewGuid().ToString())
        , SomeFloat(InFloat)
    {
    }
};
template &lt;typename ValueType&gt;
struct TMyStructMapKeyFuncs :
    BaseKeyFuncs&lt;
        TPair&lt;FMyStruct, ValueType&gt;,
        FString
    &gt;
{
private:
    typedef BaseKeyFuncs&lt;
        TPair&lt;FMyStruct, ValueType&gt;,
        FString
    &gt; Super;

public:
    typedef typename Super::ElementInitType ElementInitType;
    typedef typename Super::KeyInitType     KeyInitType;

    static KeyInitType GetSetKey(ElementInitType Element)
    {
        return Element.Key.UniqueID;
    }

    static bool Matches(KeyInitType A, KeyInitType B)
    {
        return A.Compare(B, ESearchCase::CaseSensitive) == 0;
    }

    static uint32 GetKeyHash(KeyInitType Key)
    {
        return FCrc::StrCrc32(&#42;Key);
    }
};</code></pre>
<p><code>FMyStruct</code> 具有唯一标识符，以及一些与身份无关的其他数据。<code>GetTypeHash</code> 和 <code>运算符==</code> 不适用于此，因为 <code>运算符==</code> 为实现通用目的不应忽略任何类型的数据，但同时又需要如此才能与 <code>GetTypeHash</code> 的行为保持一致，后者只关注 <code>UniqueID</code> 字段。以下步骤有助于为 <code>FMyStruct</code> 创建自定义 <code>KeyFuncs</code>：
</p><ol ><li class="Default"><p>首先，继承 <code>BaseKeyFuncs</code>，因为它可以帮助定义某些类型，包括 <code>KeyInitType</code> 和 <code>ElementInitType</code>。
</p><p><code>BaseKeyFuncs</code> 使用两个模板参数：映射的元素类型和键类型。和所有映射一样，元素类型是 <code>TPair</code>，使用 <code>FMyStruct</code> 作为其 <code>KeyType</code>，<code>TMyStructMapKeyFuncs</code> 的模板参数作为其 <code>ValueType</code>。将备用 <code>KeyFuncs</code> 用作模板，可为每个映射指定 <code>ValueType</code>，因此每次要在 <code>FMyStruct</code> 上创建键控 <code>TMap</code> 时不必定义新的 <code>KeyFuncs</code>。第二个 <code>BaseKeyFuncs</code> 参数是键类型，不要与元素存储的键区（<code>TPair</code> 的 <code>KeyType</code>）混淆。因为此映射应使用 <code>UniqueID</code>（来自 <code>FMyStruct</code>）作为键，所以此处使用 <code>FString</code>。
</p></li><li class="Default"><p>然后，定义三个必需的 <code>KeyFuncs</code> 静态函数。第一个是 <code>GetSetKey</code>，该函数返回给定元素类型的键。由于元素类型是 <code>TPair</code>，而键是 <code>UniqueID</code>，所以该函数可直接返回 <code>UniqueID</code>。
</p><p>第二个静态函数是 <code>Matches</code>，该函数接受两个元素的键（由 <code>GetSetKey</code> 获取），然后比较它们是否相等。在 <code>FString</code> 中，标准的等效测试（<code>运算符==</code>）不区分大小写；要替换为区分大小写的搜索，请用相应的大小写对比选项使用 <code>Compare</code> 函数。
</p></li><li class="Default"><p>最后，<code>GetKeyHash</code> 静态函数接受提取的键并返回其散列值。由于 <code>Matches</code> 函数区分大小写，<code>GetKeyHash</code> 也必须区分大小写。区分大小写的 <code>FCrc</code> 函数将计算键字符串的散列值。
</p></li><li class="Default"><p>现在结构已满足 <code>TMap</code> 要求的行为，可创建它的实例。
</p></li></ol><p><code>KeyFuncs</code> 参数处于最后，所以这个 <code>TMap</code></p><pre class="prettyprint"><code>    TMap&lt;
        FMyStruct,
        int32,
        FDefaultSetAllocator,
        TMyStructMapKeyFuncs&lt;int32&gt;
    &gt; MyMapToInt32;

    // Add some elements
    MyMapToInt32.Add(FMyStruct(3.14f), 5);
    MyMapToInt32.Add(FMyStruct(1.23f), 2);

    // MyMapToInt32 == &#91;
    //  {
    //      Key:{
    //          UniqueID:"D06AABBA466CAA4EB62D2F97936274E4",
    //          SomeFloat:3.14f
    //      },
    //      Value:5
    //  },
    //  {
    //      Key:{
    //          UniqueID:"0661218447650259FD4E33AD6C9C5DCB",
    //          SomeFloat:1.23f
    //      },
    //      Value:5
    //  }
    // &#93;</code></pre>
<p><code>TMap</code> 假设两个项目使用 <code>Matches</code> 比较的结果相等，则它们会从 <code>GetKeyHash</code> 返回相同的值。此外，如果对现有映射元素的键进行的修改将会改变来自这两个函数中任一个的结果，那么系统会将这种修改视作未定义的行为，因为这会使映射的内部散列失效。这些规则也适用于使用默认 <code>KeyFuncs</code> 时 <code>运算符==</code> 和 <code>GetKeyHash</code></p><h2 id="其他">其他</h2>
<p><code>CountBytes</code> 和 <code>GetAllocatedSize</code> 函数用于估计内部数组的当前内存使用情况。<code>CountBytes</code> 接受 <code>Farchive</code> 参数，而 <code>GetAllocatedSize</code> 则不会。这些函数常用于统计报告。
</p><p><code>Dump</code> 函数接受 <code>FOutputDevice</code>，并写出关于映射内容的实现信息。此函数常用于调试。</p>
																	</div>
					<!-- End of Markdown converted page content -->
				</div>
												<div id="recommendations"></div>			</div>
						  									<div id="announcement">
			<div style="display:inline-block;margin:5px;">
				欢迎帮助改进虚幻引擎文档！请告诉我们该如何更好地为您服务。
			</div>
			<div style="margin:5px;display:inline-block;">
				<div class="btn action" style="margin-top:-6px;display:inline-block;" onclick="$('#announcement').hide();window.open('https://epicgames.questionpro.com/t/AP9dGZkjp4');createCookie('announcement-read', new Date().getTime(), 30);">填写问卷调查</div>
				<div class="btn btn-default" style="margin-top:-6px;display:inline-block;" onclick="$('#announcement').hide();createCookie('announcement-read', new Date().getTime(), 30);">取消</div>
			</div>
			<div class="btn-close" style="position:absolute;right:5px;top:10px;padding:3px;width:14px;height:14px;" onclick="$('#announcement').hide();"></div>
			</div>
					</div>
	</div></body>

<!-- Mirrored from docs.unrealengine.com/4.26/zh-CN/ProgrammingAndScripting/ProgrammingWithCPP/UnrealArchitecture/TMap/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 17 Jan 2024 12:21:40 GMT -->
</html>
