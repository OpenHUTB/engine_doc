<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" dir="ltr" lang="en-US">

<!-- Mirrored from docs.unrealengine.com/4.26/zh-CN/TestingAndOptimization/Automation/AutomationSpec/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 17 Jan 2024 12:41:40 GMT -->
<head>
		<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <script src="../../../../Include/Javascript/common_zh-CN.js" type="text/javascript"></script>
	<script type="text/javascript">
		var time = new Date(0);
		var preview = false;
		var relativeHTMLPath = "https://docs.unrealengine.com/4.26/";
				var pageid = 0;
				var heroimage = "";
				var lang = "zh-CN";
				var basePath = document.location.pathname.substring(0, document.location.pathname.indexOf('/' + lang + '/') + lang.length + 1);
		document.write('<base href="' +  encodeURI(basePath) + '/TestingAndOptimization/Automation/AutomationSpec/" />');
				var udnCSS = '../../../../Include/CSS/udn_public.css';
		var udnLangCSS = '';
				udnLangCSS = './../../../../Include/CSS/udn_public_CN.css">';
				var udnOverrideCSS = '../../../../Include/CSS/skin_overrides.css';
		var udnOverrideDarkCSS = '../../../../Include/CSS/skin_overrides_dark.css';
		var fancyboxCSS = '../../../../Include/CSS/jquery.fancybox.css';
		var jqueryuiCSS = '../../../../Include/CSS/jquery-ui.min.css';
		var qtipCSS = '../../../../Include/CSS/jquery.qtip.css';
		var prettifyCSS = '../../../../Include/CSS/prettify.css';
		var navbarCSS = '../../../../Include/CSS/navBar.css';
		var twentytwentyCSS = '../../../../Include/CSS/twentytwenty.css';
		var recommendationsCSS = '../../../../Include/CSS/jquery.recommendations.css';
	</script>
    <title>自动化规范 | 虚幻引擎文档</title>
    	    <meta name=viewport content="width=device-width, initial-scale=1" />
	<meta http-equiv="Cache-control" content="no-store">
    <script  src="../../../../Include/Javascript/CustomEvent.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery-3.4.0.min.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/udn.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/udn_extras.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery-ui.min.js" type="text/javascript"></script>
	    <script  src="../../../../Include/Javascript/informational.js" type="text/javascript"></script>
	    <script  src="../../../../Include/Javascript/jquery.fancybox.pack.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.qtip.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/prettify.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.slimscroll.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.event.move.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/jquery.twentytwenty.js" type="text/javascript"></script>
    <script  src="../../../../Include/Javascript/lazysizes.min.js" type="text/javascript"></script>
	    <script  src="../../../../Include/Javascript/jquery.recommendations.js" type="text/javascript"></script>
	
    <link async rel="icon" href="../../../../../favicon.png" type="image/x-icon" />
    <link async rel="shortcut icon" href="../../../../../favicon.png" type="image/x-icon" />
    <link async href="../../../../Include/Images/touch_icon.png" rel="apple-touch-icon" />
    <link async href="../../../../Include/Images/touch_icon_114.png" sizes="114x114" rel="apple-touch-icon" />    
		<script  src="../../../../Include/Javascript/CollapsibleLists.js" type="text/javascript"></script>
	<script  src="../../../../Include/Javascript/navigationBarUI.js"></script>
	<script  src="../../../../Include/Javascript/navigationBar.js"></script>
		
	<link rel="alternate" href="https://docs.unrealengine.com/latest/en-US/TestingAndOptimization/Automation/AutomationSpec/" hreflang="x-default" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/zh-CN/TestingAndOptimization/Automation/AutomationSpec/" hreflang="zh-CN" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/ja/TestingAndOptimization/Automation/AutomationSpec/" hreflang="ja" />
<link rel="alternate" href="https://docs.unrealengine.com/latest/ko/TestingAndOptimization/Automation/AutomationSpec/" hreflang="ko" />

	<meta name="redirect" content="Programming/Automation/AutomationSpec" />
<meta name="intsourcechangelist" content="14102924" />
<meta name="availability" content="Public" />
<meta name="title" content="自动化规范" />
<meta name="description" content="概述了一种新的自动化测试类型，称为"规范"，它已经添加到我们现有的自动化测试框架中。" />
<meta name="type" content="overview" />
<meta name="skilllevel" content="advanced" />
<meta name="version" content="4.22" />
<meta name="parent" content="TestingAndOptimization/Automation" />
<meta name="order" content="" />
<meta name="keywords" content="Automation Spec" />
<meta name="topic-image" content="AutomationSpec_topic.png" />
<meta name="related" content="TestingAndOptimization/Automation/AutomationDriver" />
<meta name="crumbs" content="%ROOT%,TestingAndOptimization,TestingAndOptimization/Automation" />

	<meta name="twitter:card" content="summary_large_image" />
	<meta property="og:title" content="自动化规范" />
	<meta property="og:description" content="概述了一种新的自动化测试类型，称为"规范"，它已经添加到我们现有的自动化测试框架中。" />
		<meta property="og:image" content="" />
	</head>
<body id="webbgThree" style="visibility: hidden;" onload="document.body.style.visibility='visible';">
			<script>window.__tracking_base = 'https://tracking.unrealengine.com/';</script>
	<script src="../../../../../../tracking.unrealengine.com/tracking.js" async></script>    <div id="webThree">
				<div id="page_head">

			<edc-navigation blackListLangCodes='["de-de","es-es","es-mx","fr-fr","it-it","pt-br","ru-ru","pl-pl","tr-tr"]' locale="zh-CN" ></edc-navigation>
						<div id="pagenav">
				<div class="crumbs" id="crumbs">

	<span class="separator">></span> <a id="parent_link" href="../../index.html">测试并优化你的内容</a>

	<span class="separator">></span> <a id="parent_link" href="../index.html">自动化系统概述</a>

<span class="separator">></span> <span id="page">自动化规范</span>
</div>				<div id="pageNavRight">
								<!-- Start of Search -->
												<div id="search_container">
					<form name="bodySearch" method="get" action="https://www.unrealengine.com/zh-CN/bing-search" onsubmit="return validateSearch()">
						<input type="image" src="../../../../Include/Images/search_box_icon.png" class="searchbutton"/>
						<input type="hidden" name="filter" value="文档" />
						<input type="text" name="keyword" placeholder="搜索文档……" class="searchbox" autocomplete="off"/>
					</form>
				</div>
								<!-- End of Search -->
				<div id="skinContainer">
	<div id="skinSelect" class="btn btn-skin" onclick="ToggleMenu($('#skinMenu'), $(this));"></div>
	<div id="skinMenu">
		<div id="light" class="btn btn-select" onclick="createCookie('skin', 'light', 365);location.reload();">Light Theme</div>
		<div id="dark" class="btn btn-select" onclick="createCookie('skin', 'dark', 365);location.reload();">Dark Theme</div>
	</div>
</div>				</div>
			</div>
		</div>						<div id="navWrapper">

			 <nav id="navPanel">
				<div class="contents-table-el"><a class="contents-table-link is-parent" href="/zh-CN/index.html">首页</a></div>
				<div class="contents-table-el"><!----><!----><!----><!----><a class="contents-table-link is-parent" href="/zh-CN/Basics/index.html">理解基础概念</a><!----></div>
				<div class="contents-table-el"><a class="contents-table-link is-parent" href="/zh-CN/WorkingWithContent/index.html">管理内容</a><!----></div>
				<div class="contents-table-el"><a class="contents-table-link is-parent" href="/zh-CN/BuildingWorlds/index.html">构建虚拟世界</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/RenderingAndGraphics/index.html">设计视觉、渲染和图形效果</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/ProgrammingAndScripting/index.html">编程和脚本编写</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/InteractiveExperiences/index.html">创建交互体验</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/AnimatingObjects/index.html">为角色和对象添加动画</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/WorkingWithMedia/index.html">使用媒体</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/ProductionPipelines/index.html">建立你的开发流程</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/TestingAndOptimization/index.html">测试并优化你的内容</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/SharingAndReleasing/index.html">项目分享及发布</a><!----></div>
				<div class="contents-table-el"> <a class="contents-table-link is-parent" href="/zh-CN/Resources/index.html">示例与教学</a><!----></div>
				<div class="contents-table-el"><a class="contents-table-link is-parent" href="/zh-CN/WhatsNew/index.html">新内容</a></div>
			</nav>
			<div id="navigation" title="Click to toggle navigation menu"><span>></span></div>
		</div>		
		<div id="splitter">
		</div>
				<div id="contentContainer">
										<div id="pagedefault">
				<div id="product-banner">
	<div id="product-logo"></div>
</div>				<div id="pagecontainer" style="padding-right:0px;">
					<!-- Start of Markdown converted page content -->
																				<div class="hero  ">
						<div class="imgContainer"><img src="#" /></div>						<div class="info">
							<div id="pageTitle">
								<h1 id="H1TitleId">自动化规范</h1>
							</div>	
							<h2 >概述了一种新的自动化测试类型，称为"规范"，它已经添加到我们现有的自动化测试框架中。</h2>
							<div id="access">
								<div class="accessContainer">
																		<div class="skill_tag_filter Advanced"><a id="skill_link" href="../../../SiteIndex/index.html?skills=Advanced">Advanced</a></div>
																	</div>
							</div>
						</div>
					</div>
																				<div id="maincol">
						<div class="togglesection" id="osContainer">
	<div class="normaltitle">
		<p>Choose your operating system:</p>
	</div><div class="toggleButtons">
		<div class="btn btn-default btn-toggle OS windows" id="windows" onclick="setSelector('OS', 'windows');">
			<p>Windows</p>
		</div>
		<div class="btn btn-default btn-toggle OS mac" id="mac" onclick="setSelector('OS', 'mac');">
			<p>macOS</p>
		</div>
		<div class="btn btn-default btn-toggle OS linux" id="linux" onclick="setSelector('OS', 'linux');">
			<p>Linux</p>
		</div>
	</div>
</div>																		<div id="seeAlso">
	<div style="position:relative;">
		<div id="title">参见</div>
		<div id="pageList">
			<ul>
								<li>
					<p>
						<a id="related_link" href="../AutomationDriver/index.html" title="概述新的自动化驱动程序特性，该特性允许程序员模拟用户输入。">自动化驱动程序</a>
					</p>
				</li>
							</ul>
		</div>
	</div>
</div>
																														<div class="toc">
<div style="position:relative;">
    <div class="title">
    本页面的内容
    </div>
<div id="tocScroll">
    <ul>
	    		    			    <li id="">
	<p><a id="toc_link" href="#如何设置规范">如何设置规范</a></p>
	</li>		    			    <li id="">
	<p><a id="toc_link" href="#如何定义您的期望">如何定义您的期望</a></p>
			<ul>
							<li id="">
	<p><a id="toc_link" href="#describe">Describe</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#it">It</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#定义基本期望">定义基本期望</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#规范期望如何转化为测试">规范期望如何转化为测试</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#其他特性">其他特性</a></p>
			<ul>
							<li id="">
	<p><a id="toc_link" href="#beforeeach和aftereach">BeforeEach和AfterEach</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#asyncexecution">AsyncExecution</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#潜在完成">潜在完成</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#参数化测试">参数化测试</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#redefine">Redefine</a></p>
	</li>							<li id="">
	<p><a id="toc_link" href="#禁用测试">禁用测试</a></p>
	</li>					</ul>
	</li>							<li id="">
	<p><a id="toc_link" href="#成熟示例">成熟示例</a></p>
	</li>					</ul>
	</li>		    	        </ul>
</div>
</div>
</div>
<p>我们在现有的自动化测试框架中添加了一种新的自动化测试类型。这种新类型称为 <strong>规范</strong>。"规范"是一个术语，用于按照<a id="content_link" href="https://en.wikipedia.org/wiki/Behavior-driven_development" ><span>行为驱动设计(BDD)</span></a>方法构建的测试。这是Web开发测试中使用的一个非常常见的方法，我们将其应用到我们的C++框架。
</p><p>编写规范的原因有几个，其中包括： 
</p><ul ><li class="Default"><p>它们是自文档化的
</p></li><li class="Default"><p>它们流畅且通常不自我重复的<div class="note">
	<p>DRY（不自我重复）</p>
</div>
</p></li><li class="Default"><p>编写线程测试代码或潜在测试代码要容易得多
</p></li><li class="Default"><p>它们隔离期望（测试）
</p></li><li class="Default"><p>它们几乎可以用于所有类型的测试（功能测试、集成测试和单元测试）
</p></li></ul><h2 id="如何设置规范">如何设置规范</h2>
<p>有两种方法来定义规范的标头，这两种方法都非常类似于我们定义测试类型的现有方法。 
</p><p>最简单的方法是使用 <code>DEFINE&#95;SPEC</code> 宏，它采用的参数与所有其余测试定义宏所用的参数完全相同。 
</p><pre class="prettyprint"><code>DEFINE&#95;SPEC(MyCustomSpec, "MyGame.MyCustomSpec", EAutomationTestFlags::ProductFilter &#124; EAutomationTestFlags::ApplicationContextMask)
void MyCustomSpec::Define()
{
    //@todo 在此处写下我的期望
}</code></pre>
<p>唯一的替代方案是使用 <code>BEGIN&#95;DEFINE&#95;SPEC</code> 和 <code>END&#95;DEFINE&#95;SPEC</code> 宏。这些宏允许您将自己的成员定义为测试的一部分。在下一节中您将看到，有一个值包含与该指针相关的内容。 
</p><pre class="prettyprint"><code>BEGIN&#95;DEFINE&#95;SPEC(MyCustomSpec, "MyGame.MyCustomSpec", EAutomationTestFlags::ProductFilter &#124; EAutomationTestFlags::ApplicationContextMask)
    TSharedPtr&lt;FMyAwesomeClass&gt; AwesomeClass;
END&#95;DEFINE&#95;SPEC(MyCustomSpec)
void MyCustomSpec::Define()
{
    //@todo 在此处写下我的期望
}</code></pre>
<p>唯一的其他提示是，您需要为规范类的 <code>Define()</code> 成员编写实现，而不是像为其他测试类型编写一样为 <code>RunTests()</code> 成员编写实现。
</p><p>规范应该在文件中进行定义，文件扩展名为<code>.spec.cpp</code>，且名称不能含有"Test"一词。例如，<code>FItemCatalogService</code> 类可能包含文件 <code>ItemCatalogService.h</code>、<code>ItemCatalogService.cpp</code> 和 <code>ItemCatalogService.spec.cpp</code>。 
</p><div class="note">
	<p>这是建议性指导，而不是技术限制。</p>
</div><h2 id="如何定义您的期望">如何定义您的期望</h2>
<p>BDD的一个重要部分是，您是要测试公共API的期望，而不是测试特定实现。这样，您的测试就不会那么脆弱，从而更容易维护，如果突然出现相同API的多个不同实现，测试更有可能正常运行。 
</p><p>在规范中，使用两个不同的主要函数 <code>Describe()</code> 和 <code>It()</code> 来定义期望。
</p><h3 id="describe">Describe</h3>
<p><code>Describe()</code> 用于确定复杂期望的范围，以便它们更具可读性且更不会自我重复。使用 <code>Describe()</code> 使您的代码更加不会自我重复，这是基于它与其他支持函数（如 <code>BeforeEach()</code> 和 <code>AfterEach()</code>）之间的交互，具体如下：
</p><pre class="prettyprint"><code>void Describe(const FString&amp; Description, TFunction&lt;void()&gt; DoWork)</code></pre>
<p><code>Describe()</code> 获取一个字符串，该字符串描述其中预期的范围，并获取一个lambda，该lambda定义这些预期。
</p><p>可将 <code>Describe()</code> 放到另一个 <code>Describe()</code> 中来级联 <code>Describe()</code>。
</p><p>请记住，<code>Describe()</code> 不是一个测试，不会在实际测试运行期间执行。当第一次在规范中定义期望（或测试）时，它们只执行一次。
</p><h3 id="it">It</h3>
<p><code>It()</code> 是定义规范的实际期望的一小段代码。您可以从根 <code>Define()</code> 方法或从任意一个 <code>Describe()</code> lambda中调用 <code>It()</code>。理想情况下，应该使用 <code>It()</code> 来断言期望，但也可以使用它来为测试场景进行最终的几个设置。
</p><div class="tip">
	<p>通常，最好的做法是用"should"一词作为 <code>It()</code> 调用描述字符串的开头，表示"它应该"。</p>
</div><h3 id="定义基本期望">定义基本期望</h3>
<p>这里有一个例子，它把所有这些结合起来定义一个非常简单的期望： 
</p><pre class="prettyprint"><code>BEGIN&#95;DEFINE&#95;SPEC(MyCustomSpec, "MyGame.MyCustomClass", EAutomationTestFlags::ProductFilter &#124; EAutomationTestFlags::ApplicationContextMask)
    TSharedPtr&lt;FMyCustomClass&gt; CustomClass;
END&#95;DEFINE&#95;SPEC(MyCustomSpec)
void MyCustomSpec::Define()
{
    Describe("Execute()", &#91;this&#93;()
    {
        It("should return true when successful", &#91;this&#93;()
        {
            TestTrue("Execute", CustomClass-&gt;Execute());
        });

        It("should return false when unsuccessful", &#91;this&#93;()
        {
            TestFalse("Execute", CustomClass-&gt;Execute());
        });
    });
}</code></pre>
<p>正如您所见，这会导致测试自文档化，如果程序员花时间正确地描述期望，而没有将不同的期望组合在一起，这种情况更容易出现。将所有 <code>Describe()</code> 和 <code>It()</code> 调用组合在一起应构成可读性很强的语句，例如： 
</p><pre class="prettyprint"><code>如果成功，Execute()应返回true
如果失败，Execute()应返回false</code></pre>
<p>下面是一个更为复杂的示例，展示了自动化测试UI中成熟规范当前的状态：
</p><p><picture>
		<source data-srcset="./../../../../Images/TestingAndOptimization/Automation/AutomationSpec/AutomationSpec_MatureExample.jpg">
		<img class="  lazyload" alt="AutomationSpec_MatureExample.png" data-src="../../../../Images/TestingAndOptimization/Automation/AutomationSpec/AutomationSpec_MatureExample.jpg" />
</picture>

</p><p>本例中，<code>Driver</code>、<code>Element</code> 和 <code>Click</code> 均为 <code>Describe()</code> 调用，并由 <code>It()</code> 调用定义各种"should..."消息。
</p><p>其中，每个 <code>It()</code> 调用都成为要执行的单独测试，因此，如果某个调用失败，而其他调用成功，则可以孤立执行。这样，因为调试测试变得更加轻松，所以维护测试也会更加简单。另外，由于测试会自文档化并孤立地执行，所以，当一个测试失败时，操作人员阅读测试报告会对发生的问题有更明确的了解——而不仅仅是知道一个名为<a id="content_link" href="https://docs.unrealengine.com/en-US/API/Runtime/Core/index.html" ><span>核心</span></a>的大桶出现了故障。这意味着，问题会更快地传达给相关人员，调查问题所需的时间也会更短。
</p><p>最后，单击上述任一测试都将直接转到定义它的 <code>It()</code> 语句。
</p><h3 id="规范期望如何转化为测试">规范期望如何转化为测试</h3>
<p>以下是详细说明；不过，了解规范测试类型的底层行为，可以更容易了解以下一些复杂的特性。 
</p><p>规范测试类型仅在需要时才会执行一次 <code>Define()</code> 根函数。执行此函数时，会收集每个非 <code>Describe</code> lambda。<code>Define()</code> 完成后，会返回查看它收集的所有lambda或代码块，并为每个 <code>It()</code> 生成一组潜在命令。<br /></p><p>因此，所有 <code>BeforeEach()</code>、<code>It()</code> 和 <code>AfterEach()</code> lambda代码块都放到一个执行链中，用于执行单个测试。当要求运行一个特定测试时，规范测试类型将对此特定测试的所有命令进行排队以便执行。在这种情况下，只有上一个块发出信号表示它已经执行完毕，下一个块才会继续执行。 
</p><h3 id="其他特性">其他特性</h3>
<p>规范测试类型提供了几种其他特性，以便于编写复杂测试。特别是，它通常消除了直接使用自动化测试框架的潜在命令系统的需要，该系统虽强大却很麻烦。
</p><p>下面是规范测试类型支持的特性列表，这些特性可以帮助处理更复杂的场景： 
</p><ul ><li class="Default"><p><a id="content_link" href="#bookmark1" ><span>BeforeEach和AfterEach</span></a>
</p></li><li class="Default"><p><a id="content_link" href="#bookmark2" ><span>AsyncExecution</span></a>
</p></li><li class="Default"><p><a id="content_link" href="#bookmark3" ><span>潜在完成</span></a>
</p></li><li class="Default"><p><a id="content_link" href="#bookmark4" ><span>参数化测试</span></a>
</p></li><li class="Default"><p><a id="content_link" href="#bookmark5" ><span>重新定义</span></a>
</p></li><li class="Default"><p><a id="content_link" href="#bookmark6" ><span>禁用测试</span></a>
</p></li></ul><h4 id="beforeeach和aftereach">BeforeEach和AfterEach</h4>
<a name="bookmark1" ></a><p><code>BeforeEach()</code> 和 <code>AfterEach()</code> 是核心函数，用于编写最琐碎的规范之外的任何其他内容。使用 <code>BeforeEach()</code>，您可以在运行随后的 <code>It()</code> 代码之前运行此代码。<code>AfterEach()</code> 同理，但会在运行 <code>It()</code> 代码之后运行此代码。 
</p><div class="note">
	<p>请记住，每个"测试"只由一个It()调用组成。</p>
</div><p>例如： 
</p><pre class="prettyprint"><code>BEGIN&#95;DEFINE&#95;SPEC(AutomationSpec, "System.Automation.Spec", EAutomationTestFlags::SmokeFilter &#124; EAutomationTestFlags::ApplicationContextMask)
    FString RunOrder; 
END&#95;DEFINE&#95;SPEC(AutomationSpec)
void AutomationSpec::Define()
{
    Describe("A spec using BeforeEach and AfterEach", &#91;this&#93;()
    {
        BeforeEach(&#91;this&#93;()
        {
            RunOrder = TEXT("A");
        });

        It("will run code before each spec in the Describe and after each spec in the Describe", &#91;this&#93;()
        {
            TestEqual("RunOrder", RunOrder, TEXT("A"));
        });

        AfterEach(&#91;this&#93;()
        {
            RunOrder += TEXT("Z");
            TestEqual("RunOrder", RunOrder, TEXT("AZ"));
        });
    });
}</code></pre>
<p>在我们的示例中，先定义 <code>BeforeEach()</code>，然后定义 <code>It()</code>，最后定义 <code>AfterEach()</code>，因此代码块是从上到下执行的。虽然这不是硬性要求，但我们建议您保持这一调用逻辑顺序。您可以打乱上述三个调用的顺序，最后始终会生成相同的测试。
</p><p>在上面的示例中还会在 <code>AfterEach()</code> 中检查期望，这是极为异常的现象，也是测试规范测试类型本身的负面效应。同样，除了用于清理之外，我们不建议使用 <code>AfterEach()</code>。 
</p><p>您还可以执行多个 <code>BeforeEach()</code> 和 <code>AfterEach()</code> 调用，它们将按照定义它们的顺序被调用。正如第一个 <code>BeforeEach()</code> 调用会在第二个 <code>BeforeEach()</code> 调用之前执行，<code>AfterEach()</code> 的行为也非常类似——第一个调用在后续调用之前执行。 
</p><pre class="prettyprint"><code>BeforeEach(&#91;this&#93;()
{
    RunOrder = TEXT("A");
});

BeforeEach(&#91;this&#93;()
{
    RunOrder += TEXT("B");
});

It("will run code before each spec in the Describe and after each spec in the Describe", &#91;this&#93;()
{
    TestEqual("RunOrder", RunOrder, TEXT("AB"));
});

AfterEach(&#91;this&#93;()
{
    RunOrder += TEXT("Y");
    TestEqual("RunOrder", RunOrder, TEXT("ABY"));
});

AfterEach(&#91;this&#93;()
{
    RunOrder += TEXT("Z");
    TestEqual("RunOrder", RunOrder, TEXT("ABYZ"));
});</code></pre>
<p>此外，<code>BeforeEach()</code> 和 <code>AfterEach()</code> 受调用它们的 <code>Describe()</code> 作用域的影响。两者都只对处于相同调用作用域内的 <code>It()</code> 调用执行。 
</p><p>下面是一个复杂的示例，虽然调用顺序不当，但都得出正确的结果。
</p><pre class="prettyprint"><code>BEGIN&#95;DEFINE&#95;SPEC(AutomationSpec, "System.Automation.Spec", EAutomationTestFlags::SmokeFilter &#124; EAutomationTestFlags::ApplicationContextMask)
    FString RunOrder; 
END&#95;DEFINE&#95;SPEC(AutomationSpec)
void AutomationSpec::Define()
{
    Describe("A spec using BeforeEach and AfterEach", &#91;this&#93;()
    {
        BeforeEach(&#91;this&#93;()
        {
            RunOrder = TEXT("A");
        });

        AfterEach(&#91;this&#93;()
        {
            RunOrder += TEXT("Z");

            // 会导致
            // TestEqual("RunOrder", RunOrder, TEXT("ABCYZ"));

// 或这个，基于正在执行的It()
            // TestEqual("RunOrder", RunOrder, TEXT("ABCDXYZ"));
        });

        BeforeEach(&#91;this&#93;()
        {
            RunOrder += TEXT("B");
        });

        Describe("while nested inside another Describe", &#91;this&#93;()
        {
            AfterEach(&#91;this&#93;()
            {
                RunOrder += TEXT("Y");
            });

It("will run all BeforeEach blocks and all AfterEach blocks", &#91;this&#93;()
            {
                TestEqual("RunOrder", RunOrder, TEXT("ABC"));
            });

            BeforeEach(&#91;this&#93;()
            {
                RunOrder += TEXT("C");
            });

            Describe("while nested inside yet another Describe", &#91;this&#93;()
            {
                It("will run all BeforeEach blocks and all AfterEach blocks", &#91;this&#93;()
                {
                    TestEqual("RunOrder", RunOrder, TEXT("ABCD"));
                });

                AfterEach(&#91;this&#93;()
                {
                    RunOrder += TEXT("X");
                });

                BeforeEach(&#91;this&#93;()
                {
                    RunOrder += TEXT("D");
                });
            });
        });
    });
}</code></pre>
<h4 id="asyncexecution">AsyncExecution</h4>
<a name="bookmark2" ></a><p>利用规范测试类型，您还可轻松定义单个代码块的执行方式。只需将适当的 <code>EAsyncExecution</code> 类型传递到重载版本的 <code>BeforeEach()</code>、<code>It()</code> 和/或 <code>AfterEach()</code> 中即可。
</p><p>例如： 
</p><pre class="prettyprint"><code>BeforeEach(EAsyncExecution::TaskGraph, &#91;this&#93;() 
{
// 设置一些内容
));

It("should do something awesome", EAsyncExecution::ThreadPool, &#91;this&#93;()
{
    // 执行一些内容
});

AfterEach(EAsyncExecution::Thread, &#91;this&#93;() 
{
    // 销毁一些内容
));</code></pre>
<p>上述各个代码块都将以不同的方式执行，但采用有保障的执行顺序。<code>BeforeEach()</code> 块将作为任务在 <code>TaskGraph</code> 中运行，<code>It()</code> 将在线程池中的一个开放线程上运行，而 <code>AfterEach()</code> 将启动自己的专用线程，仅为运行一个代码块。
</p><p>当必须模拟线程敏感型场景时，例如使用<a id="content_link"filter-data="tag_automation_driver" href="../AutomationDriver/index.html" ><span>自动化驱动程序</span></a>，这些选项非常方便。
</p><p><code>AsyncExecution</code> 特性可与 <code>潜在完成（Latent Completion）</code> 特性组合起来。
</p><h4 id="潜在完成">潜在完成</h4>
<a name="bookmark3" ></a><p>有时候，您需要编写测试来执行一个需要多个帧的操作，例如在执行查询时。在这些场景中，您可以使用重载的 <code>LatentBeforeEach()</code>、<code>LatentIt()</code> 和 <code>LatentAfterEach()</code> 成员。其中，每个成员都与非潜在变体完全相同，只是它们的lambda使用一个名为 <code>Done</code> 的简单委托。 
</p><p>使用潜在变体时，规范测试类型将不会继续执行测试序列中的下一个代码块，直到主动运行的潜在代码块调用Done委托。 
</p><pre class="prettyprint"><code>LatentIt("should return available items", &#91;this&#93;(const FDoneDelegate&amp; Done)
{
    BackendService-&gt;QueryItems(this, &amp;FMyCustomSpec::HandleQueryItemComplete, Done);
});

void FMyCustomSpec::HandleQueryItemsComplete(const TArray&lt;FItem&gt;&amp; Items, FDoneDelegate Done)
{
    TestEqual("Items.Num() == 5", Items.Num(), 5);
Done.Execute();
}</code></pre>
<p>正如您在示例中看到的，您可以将 <code>Done</code> 委托作为有效荷载传递给其他回调函数，使其可被潜在代码访问。因此，当执行上面的测试时，它将不会继续为 <code>It()</code> 执行任何 <code>AfterEach()</code> 代码块，直至执行 <code>Done</code> 委托为止（即使 <code>It()</code> 代码块已经完成执行）。
</p><p><code>潜在完成</code> 特性可与 <code>AsyncExecution</code> 特性组合起来。
</p><h4 id="参数化测试">参数化测试</h4>
<a name="bookmark4" ></a><p>有时候，您需要以数据驱动的方式创建测试。而有时，这意味着从文件中读取输入并根据这些输入生成测试。其他情况下，理想的方式可能就是减少代码重复。无论哪种方式，规范测试类型都允许以一种非常自然的方式进行参数化测试。 
</p><pre class="prettyprint"><code>Describe("Basic Math", &#91;this&#93;()
{
    for (int32 Index = 0; Index &lt; 5; Index++)
    {
        It(FString::Printf(TEXT("should resolve %d + %d = %d"), Index, 2, Index + 2), &#91;this, Index&#93;()
        {
            TestEqual(FString::Printf(TEXT("%d + %d = %d"), Index, 2, Index + 2), Index + 2, Index + 2);
        });
    }
});</code></pre>
<p>正如您在上面的示例中所看到的，创建参数化测试所需要做的就是动态调用其他规范函数，这些函数将参数化数据作为lambda有效荷载的一部分传递，同时生成唯一的描述。
</p><p>在某些情况下，使用参数化测试可能会导致测试膨胀。作为单个测试的一部分，简单地从输入执行所有场景可能比较合理。您应该考虑输入的数量和生成的最终测试。以参数化的方式创建数据驱动测试的主要好处是，每个测试都可以单独运行，从而更容易重现。
</p><h4 id="redefine">Redefine</h4>
<a name="bookmark5" ></a><p>使用参数化测试时，有时可以在运行时方便地更改驱动输入的外部文件，并自动刷新测试。<code>Redefine()</code> 是规范测试类型的成员，当调用该函数时，将重新执行 <code>Define()</code> 流程。这将导致重新采集和整理测试的所有代码块。
</p><p>执行上述操作最方便的方法是创建一小段代码，以侦听输入文件的更改，并根据需要在测试上调用 <code>Redefine()</code>。
</p><h4 id="禁用测试">禁用测试</h4>
<a name="bookmark6" ></a><p>规范测试类型的每个 <code>Describe()</code>、<code>BeforeEach()</code>、<code>It()</code> 和 <code>AfterEach()</code> 成员都有一个变体，该变体以"x"为开头。例如，<code>xDescribe()</code>、<code>xBeforeEach()</code>、<code>xIt()</code> 和 <code>xAfterEach()</code>。这些变体是禁用代码块或 <code>Describe()</code> 的一种更为简单的方法。如果使用了一个 <code>xDescribe()</code>，则 <code>xDescribe()</code> 中的所有代码也都将被禁用。 
</p><p>这比注释掉需要迭代的期望要容易。
</p><h3 id="成熟示例">成熟示例</h3>
<p>您可以在 <code>Engine/Source/Developer/AutomationDriver/Private/Specs/AutomationDriver.spec.cpp</code> 中找到成熟的规范测试类型示例。这个规范目前包含120多个期望，并且在某个时候利用了大多数高级特性。
</p><p>我们的启动程序团队还拥有规范框架的多种成熟用途，其中最成熟的用途之一是围绕 <code>BuildPatchServices</code> 编写的规范。</p>
																	</div>
					<!-- End of Markdown converted page content -->
				</div>
												<div id="pageTags">
				<div class="title">标签</div>
					<div>
					<div class="keyword_tag_filter"><a id="tag_link" href="../../../SiteIndex/index.html?tags=Automation%20Spec">Automation Spec</a></div>
					</div>
				</div>
								<div id="recommendations"></div>			</div>
						  									<div id="announcement">
			<div style="display:inline-block;margin:5px;">
				欢迎帮助改进虚幻引擎文档！请告诉我们该如何更好地为您服务。
			</div>
			<div style="margin:5px;display:inline-block;">
				<div class="btn action" style="margin-top:-6px;display:inline-block;" onclick="$('#announcement').hide();window.open('https://epicgames.questionpro.com/t/AP9dGZkjp4');createCookie('announcement-read', new Date().getTime(), 30);">填写问卷调查</div>
				<div class="btn btn-default" style="margin-top:-6px;display:inline-block;" onclick="$('#announcement').hide();createCookie('announcement-read', new Date().getTime(), 30);">取消</div>
			</div>
			<div class="btn-close" style="position:absolute;right:5px;top:10px;padding:3px;width:14px;height:14px;" onclick="$('#announcement').hide();"></div>
			</div>
					</div>
	</div></body>

<!-- Mirrored from docs.unrealengine.com/4.26/zh-CN/TestingAndOptimization/Automation/AutomationSpec/ by HTTrack Website Copier/3.x [XR&CO'2014], Wed, 17 Jan 2024 12:41:41 GMT -->
</html>
